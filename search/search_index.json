{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\ude80 Do zero a implanta\u00e7\u00e3o Iniciaremos com um introdu\u00e7\u00e3o a conceitos de programa\u00e7\u00e3o web, prepara\u00e7\u00e3o do ambiente e vamos evoluindo at\u00e9 escrever nossa primeira aplica\u00e7\u00e3o utilizando t\u00e9cnicas profissionais, para no fim colocarmos a aplica\u00e7\u00e3o no ar. \u00c9 um curso pensado para iniciantes na \u00e1rea de computa\u00e7\u00e3o, curiosos, entusiastas e todo mundo que queira entender todo o processo de cria\u00e7\u00e3o de uma aplica\u00e7\u00e3o at\u00e9 sua implanta\u00e7\u00e3o. O que veremos? Est\u00e1 previsto para este curso o estudo e desenvolvimento de uma aplica\u00e7\u00e3o utilizando-se da t\u00e9cnica do tdd, que \u00e9 um desenvolvimento guiado por testes(n\u00e3o se preocupe se n\u00e3o est\u00e1 familiarizado com o termo), assim como cria\u00e7\u00e3o de um ambiente de desenvolvimento automatizado utilizando integra\u00e7\u00e3o cont\u00ednua e implanta\u00e7\u00e3o. Assustado com tantos termos t\u00e9cnicos? N\u00e3o se preocupe, voc\u00ea vai ver que as coisas s\u00e3o mais simples do que se parecem. Ao final deste curso voc\u00ea dever\u00e1 ter no ar uma aplica\u00e7\u00e3o como esta apresentada aqui . Requisitos Um computador com acesso a internet Vontade de aprender","title":"\u25b6\ufe0f Introdu\u00e7\u00e3o"},{"location":"#do-zero-a-implantacao","text":"Iniciaremos com um introdu\u00e7\u00e3o a conceitos de programa\u00e7\u00e3o web, prepara\u00e7\u00e3o do ambiente e vamos evoluindo at\u00e9 escrever nossa primeira aplica\u00e7\u00e3o utilizando t\u00e9cnicas profissionais, para no fim colocarmos a aplica\u00e7\u00e3o no ar. \u00c9 um curso pensado para iniciantes na \u00e1rea de computa\u00e7\u00e3o, curiosos, entusiastas e todo mundo que queira entender todo o processo de cria\u00e7\u00e3o de uma aplica\u00e7\u00e3o at\u00e9 sua implanta\u00e7\u00e3o.","title":"\ud83d\ude80 Do zero a implanta\u00e7\u00e3o"},{"location":"#o-que-veremos","text":"Est\u00e1 previsto para este curso o estudo e desenvolvimento de uma aplica\u00e7\u00e3o utilizando-se da t\u00e9cnica do tdd, que \u00e9 um desenvolvimento guiado por testes(n\u00e3o se preocupe se n\u00e3o est\u00e1 familiarizado com o termo), assim como cria\u00e7\u00e3o de um ambiente de desenvolvimento automatizado utilizando integra\u00e7\u00e3o cont\u00ednua e implanta\u00e7\u00e3o. Assustado com tantos termos t\u00e9cnicos? N\u00e3o se preocupe, voc\u00ea vai ver que as coisas s\u00e3o mais simples do que se parecem. Ao final deste curso voc\u00ea dever\u00e1 ter no ar uma aplica\u00e7\u00e3o como esta apresentada aqui .","title":"O que veremos?"},{"location":"#requisitos","text":"Um computador com acesso a internet Vontade de aprender","title":"Requisitos"},{"location":"criar/","text":"\ud83d\udcdd Criando uma tarefa Certo, temos a funcionalidade de listagem de tarefas j\u00e1 funcionando. listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada Vamos seguir em frente e escrever a funcionalidade de criar uma tarefa. Continuamos o ciclo do TDD e a primeira coisa a se fazer \u00e9 pensar em um teste que n\u00e3o esteja implementado. Daqui pra frente sempre que ver \u274c escreva o teste mostrado e em seguida rode os testes que devem falhar. Logo em seguida dever\u00e1 aparecer \u2705 e o trecho de c\u00f3digo que deve ser alterado. Lembre-se de rodar os testes para garantir que est\u00e3o funcionando. E n\u00e3o se esque\u00e7a que testes v\u00e3o no arquivo test_gerenciador.py e o c\u00f3digo em gerenciador.py . Passo a passo Se testarmos o recurso de tarefas utilizando o m\u00e9todo POST, veremos que teremos como retorno o c\u00f3digo de status 405 METHOD NOT ALLOWED . Para testar utilize o comando: http POST localhost:8000/tarefas Isto \u00e9 porque at\u00e9 agora s\u00f3 implementamos o m\u00e9todo get. Vamos partir disto para escrever nosso primeiro teste. Primeiro teste ent\u00e3o verificaremos o recurso tarefas utilizando o m\u00e9todo POST . O c\u00f3digo de status deve ser diferente de 405. O teste pode ser visto abaixo. \u274c def test_recurso_tarefas_deve_aceitar_o_verbo_post (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" ) assert resposta . status_code != status . HTTP_405_METHOD_NOT_ALLOWED Pr\u00f3xima etapa do ciclo \u00e9 escrevermos o c\u00f3digo suficiente para satisfazer o nosso teste. O c\u00f3digo \u00e9 simples, vamos criar um novo m\u00e9todo criar e associ\u00e1-los ao m\u00e9todo POST do recurso tarefas. \u2705 @app . post ( '/tarefas' ) def criar (): pass Ok, o teste est\u00e1 passando. Vamos criar uma nova situa\u00e7\u00e3o onde o nosso c\u00f3digo falha. Na nossa requisi\u00e7\u00e3o, caso o corpo n\u00e3o tenha um t\u00edtulo, deveremos receber o c\u00f3digo de status 422 Unprocessable Entity que significa que a \"entidade\", que neste caso \u00e9 a tarefa, foi passada com algum problema. Vamos transformar isto em um teste. \u274c def test_quando_uma_tarefa_e_submetida_deve_possuir_um_titulo (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = {}) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Agora vamos utilizar o pydantic como desserializador da nossa entrada e validador. Desseria...o que? Quando recebemos uma requisi\u00e7\u00e3o, em seu corpo temos um conte\u00fado que est\u00e1 no formato json, precisamos ler e entender esta estrutura e transformar em algo que possa manipular no python. Criaremos ent\u00e3o uma Tarefa, que possui um titulo que \u00e9 uma string. Esta tarefa \u00e9 baseada em um modelo da biblioteca pydantic. from pydantic import BaseModel # ... class Tarefa ( BaseModel ): titulo : str Adicionamos ent\u00e3o ao m\u00e9todo criar uma tarefa e isto \u00e9 suficiente para ele saber que ao ser acessado via post, deve conter em seu corpo uma tarefa com um t\u00edtulo. @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): pass E o resultado final que faz os testes passarem \u00e9: \u2705 from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Tarefa ( BaseModel ): titulo : str TAREFAS = [] @app . get ( '/tarefas' ) def listar (): return TAREFAS @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): pass E o ciclo continua, temos uma restri\u00e7\u00e3o no titulo que \u00e9 \"deve possuir entre 3 e 50 caracteres\", vamos testar isto. \u274c def test_titulo_da_tarefa_deve_conter_entre_3_e_50_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 2 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 51 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Para resolver esta valida\u00e7\u00e3o substituiremos o tipo str da nossa tarefa por constr , que em ingl\u00eas quer dizer \" constrained str \", e em bom portugu\u00eas \"string com restri\u00e7\u00f5es\". Definimos ent\u00e3o min_length (comprimento m\u00ednimo) como 3 e max_length (comprimento m\u00e1ximo) como 50. \u2705 from pydantic import BaseModel , constr class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) Testes passando, vamos continuar a construir nossa tarefa. Al\u00e9m de titulo, nossa tarefa deve possuir uma descri\u00e7\u00e3o. \u274c def test_quando_uma_tarefa_e_submetida_deve_possuir_uma_descricao (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Adicionamos a nossa tarefa o campo descri\u00e7\u00e3o. \u2705 class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : str Mas a descri\u00e7\u00e3o s\u00f3 pode ter 140 caracteres. \u274c def test_descricao_da_tarefa_pode_conter_no_maximo_140_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" , \"descricao\" : \"*\" * 141 }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Assim como o t\u00edtulo, vamos mudar de str para constr e adicionar a restri\u00e7\u00e3o no comprimento do texto. \u2705 class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) Outra coisa \u00e9 ao pedir a cria\u00e7\u00e3o da tarefa, a mesma deve ser retornada como resposta. \u274c def test_quando_criar_uma_tarefa_a_mesma_deve_ser_retornada (): cliente = TestClient ( app ) tarefa_esperada = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa_esperada ) tarefa_criada = resposta . json () assert tarefa_criada [ \"titulo\" ] == tarefa_esperada [ \"titulo\" ] assert tarefa_criada [ \"descricao\" ] == tarefa_esperada [ \"descricao\" ] TAREFAS . clear () \ud83e\udd14 E se eu retornar a tarefa? \u2705 @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): return tarefa \ud83d\ude05 Esta foi simples. Outra coisa que precisamos verificar \u00e9 que cada tarefa deve possuir um identificador \u00fanico. Para checar isto vamos adicionar duas tarefas e seus ids retornados devem ser diferentes. \u274c def test_quando_criar_uma_tarefa_seu_id_deve_ser_unico (): cliente = TestClient ( app ) tarefa1 = { \"titulo\" : \"titulo1\" , \"descricao\" : \"descricao1\" } tarefa2 = { \"titulo\" : \"titulo2\" , \"descricao\" : \"descricao1\" } resposta1 = cliente . post ( \"/tarefas\" , json = tarefa1 ) resposta2 = cliente . post ( \"/tarefas\" , json = tarefa2 ) assert resposta1 . json ()[ \"id\" ] != resposta2 . json ()[ \"id\" ] TAREFAS . clear () Como o id \u00e9 uma coisa que s\u00f3 deve aparecer na resposta, vamos a algumas mudan\u00e7as. A primeira \u00e9 que renomearemos a nossa Tarefa para TarefaEntrada e criaremos uma segunda estrutura Tarefa que \u00e9 baseada na entrada, por\u00e9m possui tamb\u00e9m um id. Para torna-lo \u00fanico, o faremos do tipo uuid , que \u00e9 um identificador universalmente \u00fanico. from uuid import UUID , uuid4 # ... class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) class Tarefa ( TarefaEntrada ): id : UUID Depois vamos no m\u00e9todo criar e transformar nossa tarefa de entrada em um dicion\u00e1rio, em seguida, adicionamos um id \u00fanico gerado pelo python. @app . post ( '/tarefas' ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) return nova_tarefa Outro detalhe \u00e9 avisar ao nosso m\u00e9todo post que utilize nossa nova estrutura para gerar a sa\u00edda no formato json. @app . post ( '/tarefas' , response_model = Tarefa ) def criar ( tarefa : TarefaEntrada ): \u2705 from uuid import UUID , uuid4 class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) class Tarefa ( TarefaEntrada ): id : UUID @app . post ( '/tarefas' , response_model = Tarefa ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) return nova_tarefa Certo, testes passando novamente. Ainda temos alguma coisa pra verificar? Sim! Nossa tarefa tamb\u00e9m deve possuir um estado que por padr\u00e3o ser\u00e1 \"n\u00e3o finalizado\". \u274c def test_quando_criar_uma_tarefa_seu_estado_padrao_e_nao_finalizado (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . json ()[ \"estado\" ] == \"n\u00e3o finalizado\" TAREFAS . clear () Como temos apenas dois estados poss\u00edveis (finalizado, n\u00e3o finalizado) para uma tarefa, vamos utilizar uma estrutura do Python que \u00e9 bastante \u00fatil para estes momentos. O Enum, \u00e9 uma estrutura que define valores limitados a algo. Um exemplo poderia ser os estados do nosso pa\u00eds, tamanhos de roupa, cores. Mas por que? Vamos pegar como exemplo o tamanho de roupa. Inicialmente nosso sistema possuia, \"Pequena\", \"M\u00e9dia\", etc. De repente por uma quest\u00e3o de economia de espa\u00e7o, estes valores modificam para \"p\", \"m\". E agora? vamos ter que ir em cada lugar do sistema que utiliza os valores e realizar a substitui\u00e7\u00e3o. Mas e se eu esquecer e utilizar o antigo. Ent\u00e3o ao inv\u00e9s de utilizarmos `` Adicionamos estado a estrutura TarefaEntrada, e seu tipo \u00e9 EstadosPossiveis . Um valor padr\u00e3o ser\u00e1 EstadosPossiveis.nao_finalizado . Voc\u00ea deve estar se perguntando por que EstadosPossiveis.nao_finalizado e n\u00e3o a string direto. \u00c9 justamente para evitar o problema citado acima de substitui\u00e7\u00e3o. \u2705 from enum import Enum class EstadosPossiveis ( str , Enum ): finalizado = \"finalizado\" nao_finalizado = \"n\u00e3o finalizado\" class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) estado : EstadosPossiveis = EstadosPossiveis . nao_finalizado Quase tudo certo, por\u00e9m o c\u00f3digo de status quando algo \u00e9 criado deve ser 201 Created . \u274c def test_quando_criar_uma_tarefa_codigo_de_status_retornado_deve_ser_201 (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . status_code == status . HTTP_201_CREATED TAREFAS . clear () Modifique o m\u00e9todo para retornar 201 quando for bem sucedido. \u2705 from fastapi import FastAPI , status # ... @app . post ( '/tarefas' , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) A \u00faltima coisa \u00e9 que no momento n\u00e3o estamos guardando a nova tarefa. \u274c def test_quando_criar_uma_tarefa_esta_deve_ser_persistida (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } cliente . post ( \"/tarefas\" , json = tarefa ) assert len ( TAREFAS ) == 1 TAREFAS . clear () \u2705 gerenciador.py @app . post ( '/tarefas' , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) TAREFAS . append ( nova_tarefa ) return nova_tarefa \ud83c\udf89 Nossos testes passaram! Agora temos as funcionalidades de cria\u00e7\u00e3o e listagem de tarefas. listar as tarefas adicionar tarefa No fim os testes ficam similar a: from fastapi import status from fastapi.testclient import TestClient from gerencia \u00b4 dor_tarefas . gerenciador import TAREFAS , app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_titulo (): TAREFAS . append ({ \"titulo\" : \"titulo 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"titulo\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_descricao (): TAREFAS . append ({ \"descricao\" : \"descricao 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"descricao\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_um_estado (): TAREFAS . append ({ \"estado\" : \"finalizado\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"estado\" in resposta . json () . pop () TAREFAS . clear () def test_recurso_tarefas_deve_aceitar_o_verbo_post (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" ) assert resposta . status_code != status . HTTP_405_METHOD_NOT_ALLOWED def test_quando_uma_tarefa_e_submetida_deve_possuir_um_titulo (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = {}) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_titulo_da_tarefa_deve_conter_entre_3_e_50_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 2 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 51 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_quando_uma_tarefa_e_submetida_deve_possuir_uma_descricao (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_descricao_da_tarefa_pode_conter_no_maximo_140_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" , \"descricao\" : \"*\" * 141 } ) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_quando_criar_uma_tarefa_a_mesma_deve_ser_retornada (): cliente = TestClient ( app ) tarefa_esperada = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa_esperada ) tarefa_criada = resposta . json () assert tarefa_criada [ \"titulo\" ] == tarefa_esperada [ \"titulo\" ] assert tarefa_criada [ \"descricao\" ] == tarefa_esperada [ \"descricao\" ] TAREFAS . clear () def test_quando_criar_uma_tarefa_seu_id_deve_ser_unico (): cliente = TestClient ( app ) tarefa1 = { \"titulo\" : \"titulo1\" , \"descricao\" : \"descricao1\" } tarefa2 = { \"titulo\" : \"titulo2\" , \"descricao\" : \"descricao1\" } resposta1 = cliente . post ( \"/tarefas\" , json = tarefa1 ) resposta2 = cliente . post ( \"/tarefas\" , json = tarefa2 ) assert resposta1 . json ()[ \"id\" ] != resposta2 . json ()[ \"id\" ] TAREFAS . clear () def test_quando_criar_uma_tarefa_seu_estado_padrao_e_nao_finalizado (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . json ()[ \"estado\" ] == \"n\u00e3o finalizado\" TAREFAS . clear () def test_quando_criar_uma_tarefa_codigo_de_status_retornado_deve_ser_201 (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . status_code == status . HTTP_201_CREATED TAREFAS . clear () def test_quando_criar_uma_tarefa_esta_deve_ser_persistida (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } cliente . post ( \"/tarefas\" , json = tarefa ) assert len ( TAREFAS ) == 1 TAREFAS . clear () E o c\u00f3digo: from enum import Enum from uuid import UUID , uuid4 from fastapi import FastAPI , status from pydantic import BaseModel , constr app = FastAPI () class EstadosPossiveis ( str , Enum ): finalizado = \"finalizado\" nao_finalizado = \"n\u00e3o finalizado\" class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) estado : EstadosPossiveis = EstadosPossiveis . nao_finalizado class Tarefa ( TarefaEntrada ): id : UUID TAREFAS = [] @app . get ( \"/tarefas\" ) def listar (): return TAREFAS @app . post ( \"/tarefas\" , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) TAREFAS . append ( nova_tarefa ) return nova_tarefa \ud83d\udd27 Testando manualmente Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. Relembrando o comando para isto \u00e9 uvicorn --reload gerenciador_tarefas.gerenciador:app . Experimente adicionar algumas tarefas utilizando o httpie . http localhost:8000 titulo=\"titulo\" descricao=\"uma descri\u00e7\u00e3o qualquer\" Lembrando que sempre temos a op\u00e7\u00e3o de verificar os recursos atrav\u00e9s da documenta\u00e7\u00e3o gerada automaticamente. Salvando a vers\u00e3o atual do c\u00f3digo Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: gerenciador_tarefas/gerenciador.py modified: tests/test_gerenciador.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) \ud83c\udfa8 Para garantir consist\u00eancia no estilo do nosso c\u00f3digo, vamos rodar os nossos linters. $ python -m isort . $ python -m black . $ python -m flake8 --exclude = .venv Caso algum erro seja encontrado, ser\u00e1 necess\u00e1rio manualmente corrig\u00ed-lo. Vamos adicionar as altera\u00e7\u00f5es nos arquivos. $ git add gerenciador_tarefas/gerenciador.py tests/test_gerenciador.py \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona funcionalidade de criar tarefas\" \ud83d\udd27 Por fim envie ao GitHub a vers\u00e3o atualizada do projeto. git push \u2601\ufe0f E coloque no ar a nova vers\u00e3o. git push heroku main \ud83c\udf89 Bom trabalho! Vamos ent\u00e3o nos desafiar agora nos proximos pasos!","title":"\ud83d\udcdd Criando uma tarefa"},{"location":"criar/#criando-uma-tarefa","text":"Certo, temos a funcionalidade de listagem de tarefas j\u00e1 funcionando. listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada Vamos seguir em frente e escrever a funcionalidade de criar uma tarefa. Continuamos o ciclo do TDD e a primeira coisa a se fazer \u00e9 pensar em um teste que n\u00e3o esteja implementado. Daqui pra frente sempre que ver \u274c escreva o teste mostrado e em seguida rode os testes que devem falhar. Logo em seguida dever\u00e1 aparecer \u2705 e o trecho de c\u00f3digo que deve ser alterado. Lembre-se de rodar os testes para garantir que est\u00e3o funcionando. E n\u00e3o se esque\u00e7a que testes v\u00e3o no arquivo test_gerenciador.py e o c\u00f3digo em gerenciador.py .","title":"\ud83d\udcdd Criando uma tarefa"},{"location":"criar/#passo-a-passo","text":"Se testarmos o recurso de tarefas utilizando o m\u00e9todo POST, veremos que teremos como retorno o c\u00f3digo de status 405 METHOD NOT ALLOWED . Para testar utilize o comando: http POST localhost:8000/tarefas Isto \u00e9 porque at\u00e9 agora s\u00f3 implementamos o m\u00e9todo get. Vamos partir disto para escrever nosso primeiro teste. Primeiro teste ent\u00e3o verificaremos o recurso tarefas utilizando o m\u00e9todo POST . O c\u00f3digo de status deve ser diferente de 405. O teste pode ser visto abaixo. \u274c def test_recurso_tarefas_deve_aceitar_o_verbo_post (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" ) assert resposta . status_code != status . HTTP_405_METHOD_NOT_ALLOWED Pr\u00f3xima etapa do ciclo \u00e9 escrevermos o c\u00f3digo suficiente para satisfazer o nosso teste. O c\u00f3digo \u00e9 simples, vamos criar um novo m\u00e9todo criar e associ\u00e1-los ao m\u00e9todo POST do recurso tarefas. \u2705 @app . post ( '/tarefas' ) def criar (): pass Ok, o teste est\u00e1 passando. Vamos criar uma nova situa\u00e7\u00e3o onde o nosso c\u00f3digo falha. Na nossa requisi\u00e7\u00e3o, caso o corpo n\u00e3o tenha um t\u00edtulo, deveremos receber o c\u00f3digo de status 422 Unprocessable Entity que significa que a \"entidade\", que neste caso \u00e9 a tarefa, foi passada com algum problema. Vamos transformar isto em um teste. \u274c def test_quando_uma_tarefa_e_submetida_deve_possuir_um_titulo (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = {}) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Agora vamos utilizar o pydantic como desserializador da nossa entrada e validador. Desseria...o que? Quando recebemos uma requisi\u00e7\u00e3o, em seu corpo temos um conte\u00fado que est\u00e1 no formato json, precisamos ler e entender esta estrutura e transformar em algo que possa manipular no python. Criaremos ent\u00e3o uma Tarefa, que possui um titulo que \u00e9 uma string. Esta tarefa \u00e9 baseada em um modelo da biblioteca pydantic. from pydantic import BaseModel # ... class Tarefa ( BaseModel ): titulo : str Adicionamos ent\u00e3o ao m\u00e9todo criar uma tarefa e isto \u00e9 suficiente para ele saber que ao ser acessado via post, deve conter em seu corpo uma tarefa com um t\u00edtulo. @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): pass E o resultado final que faz os testes passarem \u00e9: \u2705 from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Tarefa ( BaseModel ): titulo : str TAREFAS = [] @app . get ( '/tarefas' ) def listar (): return TAREFAS @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): pass E o ciclo continua, temos uma restri\u00e7\u00e3o no titulo que \u00e9 \"deve possuir entre 3 e 50 caracteres\", vamos testar isto. \u274c def test_titulo_da_tarefa_deve_conter_entre_3_e_50_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 2 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 51 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Para resolver esta valida\u00e7\u00e3o substituiremos o tipo str da nossa tarefa por constr , que em ingl\u00eas quer dizer \" constrained str \", e em bom portugu\u00eas \"string com restri\u00e7\u00f5es\". Definimos ent\u00e3o min_length (comprimento m\u00ednimo) como 3 e max_length (comprimento m\u00e1ximo) como 50. \u2705 from pydantic import BaseModel , constr class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) Testes passando, vamos continuar a construir nossa tarefa. Al\u00e9m de titulo, nossa tarefa deve possuir uma descri\u00e7\u00e3o. \u274c def test_quando_uma_tarefa_e_submetida_deve_possuir_uma_descricao (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Adicionamos a nossa tarefa o campo descri\u00e7\u00e3o. \u2705 class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : str Mas a descri\u00e7\u00e3o s\u00f3 pode ter 140 caracteres. \u274c def test_descricao_da_tarefa_pode_conter_no_maximo_140_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" , \"descricao\" : \"*\" * 141 }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY Assim como o t\u00edtulo, vamos mudar de str para constr e adicionar a restri\u00e7\u00e3o no comprimento do texto. \u2705 class Tarefa ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) Outra coisa \u00e9 ao pedir a cria\u00e7\u00e3o da tarefa, a mesma deve ser retornada como resposta. \u274c def test_quando_criar_uma_tarefa_a_mesma_deve_ser_retornada (): cliente = TestClient ( app ) tarefa_esperada = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa_esperada ) tarefa_criada = resposta . json () assert tarefa_criada [ \"titulo\" ] == tarefa_esperada [ \"titulo\" ] assert tarefa_criada [ \"descricao\" ] == tarefa_esperada [ \"descricao\" ] TAREFAS . clear () \ud83e\udd14 E se eu retornar a tarefa? \u2705 @app . post ( '/tarefas' ) def criar ( tarefa : Tarefa ): return tarefa \ud83d\ude05 Esta foi simples. Outra coisa que precisamos verificar \u00e9 que cada tarefa deve possuir um identificador \u00fanico. Para checar isto vamos adicionar duas tarefas e seus ids retornados devem ser diferentes. \u274c def test_quando_criar_uma_tarefa_seu_id_deve_ser_unico (): cliente = TestClient ( app ) tarefa1 = { \"titulo\" : \"titulo1\" , \"descricao\" : \"descricao1\" } tarefa2 = { \"titulo\" : \"titulo2\" , \"descricao\" : \"descricao1\" } resposta1 = cliente . post ( \"/tarefas\" , json = tarefa1 ) resposta2 = cliente . post ( \"/tarefas\" , json = tarefa2 ) assert resposta1 . json ()[ \"id\" ] != resposta2 . json ()[ \"id\" ] TAREFAS . clear () Como o id \u00e9 uma coisa que s\u00f3 deve aparecer na resposta, vamos a algumas mudan\u00e7as. A primeira \u00e9 que renomearemos a nossa Tarefa para TarefaEntrada e criaremos uma segunda estrutura Tarefa que \u00e9 baseada na entrada, por\u00e9m possui tamb\u00e9m um id. Para torna-lo \u00fanico, o faremos do tipo uuid , que \u00e9 um identificador universalmente \u00fanico. from uuid import UUID , uuid4 # ... class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) class Tarefa ( TarefaEntrada ): id : UUID Depois vamos no m\u00e9todo criar e transformar nossa tarefa de entrada em um dicion\u00e1rio, em seguida, adicionamos um id \u00fanico gerado pelo python. @app . post ( '/tarefas' ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) return nova_tarefa Outro detalhe \u00e9 avisar ao nosso m\u00e9todo post que utilize nossa nova estrutura para gerar a sa\u00edda no formato json. @app . post ( '/tarefas' , response_model = Tarefa ) def criar ( tarefa : TarefaEntrada ): \u2705 from uuid import UUID , uuid4 class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) class Tarefa ( TarefaEntrada ): id : UUID @app . post ( '/tarefas' , response_model = Tarefa ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) return nova_tarefa Certo, testes passando novamente. Ainda temos alguma coisa pra verificar? Sim! Nossa tarefa tamb\u00e9m deve possuir um estado que por padr\u00e3o ser\u00e1 \"n\u00e3o finalizado\". \u274c def test_quando_criar_uma_tarefa_seu_estado_padrao_e_nao_finalizado (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . json ()[ \"estado\" ] == \"n\u00e3o finalizado\" TAREFAS . clear () Como temos apenas dois estados poss\u00edveis (finalizado, n\u00e3o finalizado) para uma tarefa, vamos utilizar uma estrutura do Python que \u00e9 bastante \u00fatil para estes momentos. O Enum, \u00e9 uma estrutura que define valores limitados a algo. Um exemplo poderia ser os estados do nosso pa\u00eds, tamanhos de roupa, cores. Mas por que? Vamos pegar como exemplo o tamanho de roupa. Inicialmente nosso sistema possuia, \"Pequena\", \"M\u00e9dia\", etc. De repente por uma quest\u00e3o de economia de espa\u00e7o, estes valores modificam para \"p\", \"m\". E agora? vamos ter que ir em cada lugar do sistema que utiliza os valores e realizar a substitui\u00e7\u00e3o. Mas e se eu esquecer e utilizar o antigo. Ent\u00e3o ao inv\u00e9s de utilizarmos `` Adicionamos estado a estrutura TarefaEntrada, e seu tipo \u00e9 EstadosPossiveis . Um valor padr\u00e3o ser\u00e1 EstadosPossiveis.nao_finalizado . Voc\u00ea deve estar se perguntando por que EstadosPossiveis.nao_finalizado e n\u00e3o a string direto. \u00c9 justamente para evitar o problema citado acima de substitui\u00e7\u00e3o. \u2705 from enum import Enum class EstadosPossiveis ( str , Enum ): finalizado = \"finalizado\" nao_finalizado = \"n\u00e3o finalizado\" class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) estado : EstadosPossiveis = EstadosPossiveis . nao_finalizado Quase tudo certo, por\u00e9m o c\u00f3digo de status quando algo \u00e9 criado deve ser 201 Created . \u274c def test_quando_criar_uma_tarefa_codigo_de_status_retornado_deve_ser_201 (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . status_code == status . HTTP_201_CREATED TAREFAS . clear () Modifique o m\u00e9todo para retornar 201 quando for bem sucedido. \u2705 from fastapi import FastAPI , status # ... @app . post ( '/tarefas' , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) A \u00faltima coisa \u00e9 que no momento n\u00e3o estamos guardando a nova tarefa. \u274c def test_quando_criar_uma_tarefa_esta_deve_ser_persistida (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } cliente . post ( \"/tarefas\" , json = tarefa ) assert len ( TAREFAS ) == 1 TAREFAS . clear () \u2705 gerenciador.py @app . post ( '/tarefas' , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) TAREFAS . append ( nova_tarefa ) return nova_tarefa \ud83c\udf89 Nossos testes passaram! Agora temos as funcionalidades de cria\u00e7\u00e3o e listagem de tarefas. listar as tarefas adicionar tarefa No fim os testes ficam similar a: from fastapi import status from fastapi.testclient import TestClient from gerencia \u00b4 dor_tarefas . gerenciador import TAREFAS , app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_titulo (): TAREFAS . append ({ \"titulo\" : \"titulo 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"titulo\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_descricao (): TAREFAS . append ({ \"descricao\" : \"descricao 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"descricao\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_um_estado (): TAREFAS . append ({ \"estado\" : \"finalizado\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"estado\" in resposta . json () . pop () TAREFAS . clear () def test_recurso_tarefas_deve_aceitar_o_verbo_post (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" ) assert resposta . status_code != status . HTTP_405_METHOD_NOT_ALLOWED def test_quando_uma_tarefa_e_submetida_deve_possuir_um_titulo (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = {}) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_titulo_da_tarefa_deve_conter_entre_3_e_50_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 2 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : 51 * \"*\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_quando_uma_tarefa_e_submetida_deve_possuir_uma_descricao (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" }) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_descricao_da_tarefa_pode_conter_no_maximo_140_caracteres (): cliente = TestClient ( app ) resposta = cliente . post ( \"/tarefas\" , json = { \"titulo\" : \"titulo\" , \"descricao\" : \"*\" * 141 } ) assert resposta . status_code == status . HTTP_422_UNPROCESSABLE_ENTITY def test_quando_criar_uma_tarefa_a_mesma_deve_ser_retornada (): cliente = TestClient ( app ) tarefa_esperada = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa_esperada ) tarefa_criada = resposta . json () assert tarefa_criada [ \"titulo\" ] == tarefa_esperada [ \"titulo\" ] assert tarefa_criada [ \"descricao\" ] == tarefa_esperada [ \"descricao\" ] TAREFAS . clear () def test_quando_criar_uma_tarefa_seu_id_deve_ser_unico (): cliente = TestClient ( app ) tarefa1 = { \"titulo\" : \"titulo1\" , \"descricao\" : \"descricao1\" } tarefa2 = { \"titulo\" : \"titulo2\" , \"descricao\" : \"descricao1\" } resposta1 = cliente . post ( \"/tarefas\" , json = tarefa1 ) resposta2 = cliente . post ( \"/tarefas\" , json = tarefa2 ) assert resposta1 . json ()[ \"id\" ] != resposta2 . json ()[ \"id\" ] TAREFAS . clear () def test_quando_criar_uma_tarefa_seu_estado_padrao_e_nao_finalizado (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . json ()[ \"estado\" ] == \"n\u00e3o finalizado\" TAREFAS . clear () def test_quando_criar_uma_tarefa_codigo_de_status_retornado_deve_ser_201 (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } resposta = cliente . post ( \"/tarefas\" , json = tarefa ) assert resposta . status_code == status . HTTP_201_CREATED TAREFAS . clear () def test_quando_criar_uma_tarefa_esta_deve_ser_persistida (): cliente = TestClient ( app ) tarefa = { \"titulo\" : \"titulo\" , \"descricao\" : \"descricao\" } cliente . post ( \"/tarefas\" , json = tarefa ) assert len ( TAREFAS ) == 1 TAREFAS . clear () E o c\u00f3digo: from enum import Enum from uuid import UUID , uuid4 from fastapi import FastAPI , status from pydantic import BaseModel , constr app = FastAPI () class EstadosPossiveis ( str , Enum ): finalizado = \"finalizado\" nao_finalizado = \"n\u00e3o finalizado\" class TarefaEntrada ( BaseModel ): titulo : constr ( min_length = 3 , max_length = 50 ) descricao : constr ( max_length = 140 ) estado : EstadosPossiveis = EstadosPossiveis . nao_finalizado class Tarefa ( TarefaEntrada ): id : UUID TAREFAS = [] @app . get ( \"/tarefas\" ) def listar (): return TAREFAS @app . post ( \"/tarefas\" , response_model = Tarefa , status_code = status . HTTP_201_CREATED ) def criar ( tarefa : TarefaEntrada ): nova_tarefa = tarefa . dict () nova_tarefa . update ({ \"id\" : uuid4 ()}) TAREFAS . append ( nova_tarefa ) return nova_tarefa","title":"Passo a passo"},{"location":"criar/#testando-manualmente","text":"Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. Relembrando o comando para isto \u00e9 uvicorn --reload gerenciador_tarefas.gerenciador:app . Experimente adicionar algumas tarefas utilizando o httpie . http localhost:8000 titulo=\"titulo\" descricao=\"uma descri\u00e7\u00e3o qualquer\" Lembrando que sempre temos a op\u00e7\u00e3o de verificar os recursos atrav\u00e9s da documenta\u00e7\u00e3o gerada automaticamente.","title":"\ud83d\udd27 Testando manualmente"},{"location":"criar/#salvando-a-versao-atual-do-codigo","text":"Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: gerenciador_tarefas/gerenciador.py modified: tests/test_gerenciador.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) \ud83c\udfa8 Para garantir consist\u00eancia no estilo do nosso c\u00f3digo, vamos rodar os nossos linters. $ python -m isort . $ python -m black . $ python -m flake8 --exclude = .venv Caso algum erro seja encontrado, ser\u00e1 necess\u00e1rio manualmente corrig\u00ed-lo. Vamos adicionar as altera\u00e7\u00f5es nos arquivos. $ git add gerenciador_tarefas/gerenciador.py tests/test_gerenciador.py \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona funcionalidade de criar tarefas\" \ud83d\udd27 Por fim envie ao GitHub a vers\u00e3o atualizada do projeto. git push \u2601\ufe0f E coloque no ar a nova vers\u00e3o. git push heroku main \ud83c\udf89 Bom trabalho! Vamos ent\u00e3o nos desafiar agora nos proximos pasos!","title":"Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"deploy/","text":"\ud83d\ude80 Mandando um foguete para o espa\u00e7o Hora do deploy Neste passo iremos colocar no ar a aplica\u00e7\u00e3o utilizando a plataforma heroku . A heroku \u00e9 uma plataforma de nuvem como servi\u00e7o, suportando v\u00e1rias linguagens de programa\u00e7\u00e3o que \u00e9 utilizada como modelo de implementa\u00e7\u00e3o de aplicativos web. Em termos simples, a plataforma recebe a sua base de c\u00f3digo, identifica a linguagem de programa\u00e7\u00e3o e ferramentas utilizadas e coloca no ar sua aplica\u00e7\u00e3o, sem precisar se preocupar com configura\u00e7\u00e3o complexa de infraestrutura. Quando utilizamos o termo deploy , estamos falando da implementa\u00e7\u00e3o da nossa aplica\u00e7\u00e3o web, ou seja, colocar a nossa aplica\u00e7\u00e3o no ar. Primeiro passo para fazermos deploy da vers\u00e3o atual do nosso software \u00e9 se registrar na plataforma. \u00c9 uma plataforma gr\u00e1tis para aplicativos de pequeno porte e uma op\u00e7\u00e3o tamb\u00e9m para aplicativos maiores. Acesse https://signup.heroku.com/ e preencha o formul\u00e1rio. Em um terminal fa\u00e7a login em sua conta rec\u00e9m criada atrav\u00e9s do comando heroku login . Crie uma aplica\u00e7\u00e3o no Heroku, preparando a heroku para receber seu c\u00f3digo-fonte. $ heroku create Creating app... done , \u2b22 agile-river-58363 https://agile-river-58363.herokuapp.com/ | https://git.heroku.com/agile-river-58363.git Com este comando um reposit\u00f3rio remoto \u00e9 vinculado ao seu reposit\u00f3rio local e cada vez que quiser modificar a vers\u00e3o do c\u00f3digo rodando, basta enviar seu c\u00f3digo para este reposit\u00f3rio remoto. Esta a\u00e7\u00e3o desencadeia toda uma nova implementa\u00e7\u00e3o da sua aplica\u00e7\u00e3o. Antes de enviar pela primeira vez nosso c\u00f3digo, vamos fazer as \u00faltimas configura\u00e7\u00f5es necess\u00e1rias. O Heroku utiliza um arquivo chamado Procfile que cont\u00e9m informa\u00e7\u00f5es de como rodar sua aplica\u00e7\u00e3o. Crie este arquivo com o seguinte conte\u00fado. web: uvicorn --host=0.0.0.0 --port=$PORT gerenciador_tarefas.gerenciador:app Salve a vers\u00e3o atual da nossa aplica\u00e7\u00e3o para implanta\u00e7\u00e3o. $ git add Procfile $ git commit -m \"Adiciona arquivos para implanta\u00e7\u00e3o no heroku\" Agora vamos a implanta\u00e7\u00e3o do sistema. \u00c9 simples como git push heroku main . $ git push heroku main Enumerating objects: 5 , done . Counting objects: 100 % ( 5 /5 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 3 /3 ) , 303 bytes | 303 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Compressing source files... done . remote: Building source: remote: remote: -----> Python app detected remote: -----> Installing requirements with pip ... remote: Procfile declares types -> web remote: remote: -----> Compressing... remote: Done: 55 .6M remote: -----> Launching... remote: Released v4 remote: https://agile-river-58363.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done . To https://git.heroku.com/agile-river-58363.git 629aed8..8710ff8 main -> main Deu certo? Para verificarmos se a implanta\u00e7\u00e3o deu certo, digite heroku open e lembre-se que o recurso est\u00e1 em /tarefas ou copie a url retornada no comando de implanta\u00e7\u00e3o acrescentando /tarefas e utilize o httpie para testar assim como foi feito localmente. No nosso exemplo seria http https://agile-river-58363.herokuapp.com/tarefas . Verifique se uma resposta 200 OK foi obtida. \ud83d\ude05 Acabou, \u00e9 isso pessoal! J\u00e1 temos uma aplica\u00e7\u00e3o no ar e podemos ir embora. Brincadeira, foi legal ter a nossa primeira vers\u00e3o da aplica\u00e7\u00e3o no ar, mas agora precisamos evolu\u00ed-la.","title":"\ud83d\ude80 Mandando um foguete pro espa\u00e7o"},{"location":"deploy/#mandando-um-foguete-para-o-espaco","text":"","title":"\ud83d\ude80 Mandando um foguete para o espa\u00e7o"},{"location":"deploy/#hora-do-deploy","text":"Neste passo iremos colocar no ar a aplica\u00e7\u00e3o utilizando a plataforma heroku . A heroku \u00e9 uma plataforma de nuvem como servi\u00e7o, suportando v\u00e1rias linguagens de programa\u00e7\u00e3o que \u00e9 utilizada como modelo de implementa\u00e7\u00e3o de aplicativos web. Em termos simples, a plataforma recebe a sua base de c\u00f3digo, identifica a linguagem de programa\u00e7\u00e3o e ferramentas utilizadas e coloca no ar sua aplica\u00e7\u00e3o, sem precisar se preocupar com configura\u00e7\u00e3o complexa de infraestrutura. Quando utilizamos o termo deploy , estamos falando da implementa\u00e7\u00e3o da nossa aplica\u00e7\u00e3o web, ou seja, colocar a nossa aplica\u00e7\u00e3o no ar. Primeiro passo para fazermos deploy da vers\u00e3o atual do nosso software \u00e9 se registrar na plataforma. \u00c9 uma plataforma gr\u00e1tis para aplicativos de pequeno porte e uma op\u00e7\u00e3o tamb\u00e9m para aplicativos maiores. Acesse https://signup.heroku.com/ e preencha o formul\u00e1rio. Em um terminal fa\u00e7a login em sua conta rec\u00e9m criada atrav\u00e9s do comando heroku login . Crie uma aplica\u00e7\u00e3o no Heroku, preparando a heroku para receber seu c\u00f3digo-fonte. $ heroku create Creating app... done , \u2b22 agile-river-58363 https://agile-river-58363.herokuapp.com/ | https://git.heroku.com/agile-river-58363.git Com este comando um reposit\u00f3rio remoto \u00e9 vinculado ao seu reposit\u00f3rio local e cada vez que quiser modificar a vers\u00e3o do c\u00f3digo rodando, basta enviar seu c\u00f3digo para este reposit\u00f3rio remoto. Esta a\u00e7\u00e3o desencadeia toda uma nova implementa\u00e7\u00e3o da sua aplica\u00e7\u00e3o. Antes de enviar pela primeira vez nosso c\u00f3digo, vamos fazer as \u00faltimas configura\u00e7\u00f5es necess\u00e1rias. O Heroku utiliza um arquivo chamado Procfile que cont\u00e9m informa\u00e7\u00f5es de como rodar sua aplica\u00e7\u00e3o. Crie este arquivo com o seguinte conte\u00fado. web: uvicorn --host=0.0.0.0 --port=$PORT gerenciador_tarefas.gerenciador:app Salve a vers\u00e3o atual da nossa aplica\u00e7\u00e3o para implanta\u00e7\u00e3o. $ git add Procfile $ git commit -m \"Adiciona arquivos para implanta\u00e7\u00e3o no heroku\" Agora vamos a implanta\u00e7\u00e3o do sistema. \u00c9 simples como git push heroku main . $ git push heroku main Enumerating objects: 5 , done . Counting objects: 100 % ( 5 /5 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 3 /3 ) , 303 bytes | 303 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Compressing source files... done . remote: Building source: remote: remote: -----> Python app detected remote: -----> Installing requirements with pip ... remote: Procfile declares types -> web remote: remote: -----> Compressing... remote: Done: 55 .6M remote: -----> Launching... remote: Released v4 remote: https://agile-river-58363.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done . To https://git.heroku.com/agile-river-58363.git 629aed8..8710ff8 main -> main","title":"Hora do deploy"},{"location":"deploy/#deu-certo","text":"Para verificarmos se a implanta\u00e7\u00e3o deu certo, digite heroku open e lembre-se que o recurso est\u00e1 em /tarefas ou copie a url retornada no comando de implanta\u00e7\u00e3o acrescentando /tarefas e utilize o httpie para testar assim como foi feito localmente. No nosso exemplo seria http https://agile-river-58363.herokuapp.com/tarefas . Verifique se uma resposta 200 OK foi obtida. \ud83d\ude05 Acabou, \u00e9 isso pessoal! J\u00e1 temos uma aplica\u00e7\u00e3o no ar e podemos ir embora. Brincadeira, foi legal ter a nossa primeira vers\u00e3o da aplica\u00e7\u00e3o no ar, mas agora precisamos evolu\u00ed-la.","title":"Deu certo?"},{"location":"desafio/","text":"\ud83c\udfc6 O desafio \u00c0 partir de agora, o seu desafio \u00e9 continuar escrevendo as funcionalidades que faltam, mas vou te dar umas dicas. Relembrando, ainda temos as seguintes tarefas a serem feitas. listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada \u274c Remover tarefas A remo\u00e7\u00e3o de tarefas consiste em buscar uma tarefa e em seguida remove-la. O m\u00e9todo utilizado \u00e9 o DELETE . O c\u00f3digo de status retornado mais comum \u00e9 o 204 No Content . Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 . Caso n\u00e3o encontra uma tarefa, o c\u00f3digo de status 404 Not Found deve ser retornado. Tip Para n\u00e3o retornar conte\u00fado no corpo da resposta, utilize `Response(status_code=status.HTTP_204_NO_CONTENT). \ud83d\udcd7 Ordenar a listagem por estado J\u00e1 temos a listagem pronta mas n\u00e3o garantimos que sua ordena\u00e7\u00e3o est\u00e1 correta. Um teste que pode ser escrito aqui \u00e9 adi\u00e7\u00e3o de duas tarefas, sendo a primeira finalizada e a segunda n\u00e3o finalizada. A exibi\u00e7\u00e3o da listagem de tarefas deve apresentar a segunda primeiro. Para fazer esta checagem, verifique a resposta e a ordem das tarefas retornadas. A fun\u00e7\u00e3o sorted pode ser seu aliado para resolver este problema. Outra fun\u00e7\u00e3o bastante \u00fatil \u00e9 a itemgetter que pode ser utilizada no par\u00e2metro key da fun\u00e7\u00e3o sorted. Uma altera\u00e7\u00e3o que pode ser feita na listagem \u00e9 utiliza\u00e7\u00e3o de list[Tarefa] como modelo de resposta( par\u00e2metro response_model no decorador), esta mudan\u00e7a ajuda a melhorar a documenta\u00e7\u00e3o autogerada. Warning itemgetter pode ser obtido atrav\u00e9s do pacote operator. from operator import itemgetter \u2611\ufe0f Finalizar uma tarefa Finalizar uma tarefa, pode ser representado atrav\u00e9s do m\u00e9todo PUT ou PATCH , modificando o valor de estado de uma tarefa. Devemos procurar uma tarefa e caso n\u00e3o seja encontrada, o c\u00f3digo de status 404 Not Found deve ser retornado. Os campos a serem modificados podem ser inv\u00e1lidos, caso isto ocorra everemos avisar ao cliente o seu erro. O c\u00f3digo de status 422 Unprocessable Entity pode ser utilizado aqui. Se bem sucedido o c\u00f3digo de status 200 OK deve ser retornado e o corpo da resposta deve conter a tarefa com o valor j\u00e1 modificado. Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 . \ud83d\udcdc Detalhando tarefas Detalhar uma tarefa \u00e9 busca-la na lista de tarefas e exibir seu valor. Caso a tarefa n\u00e3o seja encontrada o c\u00f3digo de status 404 Not Found deve ser retornado. Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 . O c\u00f3digo de status retornado quando bem sucedido \u00e9 200 OK . \ud83c\udfc1 Concluindo Assim finalizamos este guia, espero que tenha curtido bastante esta jornada de aprendizado. Ainda temos v\u00e1rias coisas n\u00e3o abordadas neste guia que complementam nossa aplica\u00e7\u00e3o, mas que tornariam a did\u00e1tica pior. Caso tenha gostado, n\u00e3o deixe de estrelar o reposit\u00f3rio como forma de gratid\u00e3o. Isto motiva a escrever mais materiais interessantes como este em portugu\u00eas.","title":"\ud83c\udfc6 O desafio"},{"location":"desafio/#o-desafio","text":"\u00c0 partir de agora, o seu desafio \u00e9 continuar escrevendo as funcionalidades que faltam, mas vou te dar umas dicas. Relembrando, ainda temos as seguintes tarefas a serem feitas. listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada","title":"\ud83c\udfc6 O desafio"},{"location":"desafio/#remover-tarefas","text":"A remo\u00e7\u00e3o de tarefas consiste em buscar uma tarefa e em seguida remove-la. O m\u00e9todo utilizado \u00e9 o DELETE . O c\u00f3digo de status retornado mais comum \u00e9 o 204 No Content . Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 . Caso n\u00e3o encontra uma tarefa, o c\u00f3digo de status 404 Not Found deve ser retornado. Tip Para n\u00e3o retornar conte\u00fado no corpo da resposta, utilize `Response(status_code=status.HTTP_204_NO_CONTENT).","title":"\u274c Remover tarefas"},{"location":"desafio/#ordenar-a-listagem-por-estado","text":"J\u00e1 temos a listagem pronta mas n\u00e3o garantimos que sua ordena\u00e7\u00e3o est\u00e1 correta. Um teste que pode ser escrito aqui \u00e9 adi\u00e7\u00e3o de duas tarefas, sendo a primeira finalizada e a segunda n\u00e3o finalizada. A exibi\u00e7\u00e3o da listagem de tarefas deve apresentar a segunda primeiro. Para fazer esta checagem, verifique a resposta e a ordem das tarefas retornadas. A fun\u00e7\u00e3o sorted pode ser seu aliado para resolver este problema. Outra fun\u00e7\u00e3o bastante \u00fatil \u00e9 a itemgetter que pode ser utilizada no par\u00e2metro key da fun\u00e7\u00e3o sorted. Uma altera\u00e7\u00e3o que pode ser feita na listagem \u00e9 utiliza\u00e7\u00e3o de list[Tarefa] como modelo de resposta( par\u00e2metro response_model no decorador), esta mudan\u00e7a ajuda a melhorar a documenta\u00e7\u00e3o autogerada. Warning itemgetter pode ser obtido atrav\u00e9s do pacote operator. from operator import itemgetter","title":"\ud83d\udcd7 Ordenar a listagem por estado"},{"location":"desafio/#finalizar-uma-tarefa","text":"Finalizar uma tarefa, pode ser representado atrav\u00e9s do m\u00e9todo PUT ou PATCH , modificando o valor de estado de uma tarefa. Devemos procurar uma tarefa e caso n\u00e3o seja encontrada, o c\u00f3digo de status 404 Not Found deve ser retornado. Os campos a serem modificados podem ser inv\u00e1lidos, caso isto ocorra everemos avisar ao cliente o seu erro. O c\u00f3digo de status 422 Unprocessable Entity pode ser utilizado aqui. Se bem sucedido o c\u00f3digo de status 200 OK deve ser retornado e o corpo da resposta deve conter a tarefa com o valor j\u00e1 modificado. Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 .","title":"\u2611\ufe0f Finalizar uma tarefa"},{"location":"desafio/#detalhando-tarefas","text":"Detalhar uma tarefa \u00e9 busca-la na lista de tarefas e exibir seu valor. Caso a tarefa n\u00e3o seja encontrada o c\u00f3digo de status 404 Not Found deve ser retornado. Voc\u00ea deve especificar o id da tarefa a ser removida na url /tarefas/86d92774-281c-4e5a-87f2-69029177bfd2 . O c\u00f3digo de status retornado quando bem sucedido \u00e9 200 OK .","title":"\ud83d\udcdc Detalhando tarefas"},{"location":"desafio/#concluindo","text":"Assim finalizamos este guia, espero que tenha curtido bastante esta jornada de aprendizado. Ainda temos v\u00e1rias coisas n\u00e3o abordadas neste guia que complementam nossa aplica\u00e7\u00e3o, mas que tornariam a did\u00e1tica pior. Caso tenha gostado, n\u00e3o deixe de estrelar o reposit\u00f3rio como forma de gratid\u00e3o. Isto motiva a escrever mais materiais interessantes como este em portugu\u00eas.","title":"\ud83c\udfc1 Concluindo"},{"location":"ferramentas/","text":"\ud83d\udd28 Escolhendo as melhores ferramentas \ud83c\udf74 Um bom chef escolhe as melhores ferramentas Uma analogia que normalmente fa\u00e7o \u00e9 que programar \u00e9 igual a cozinhar, voc\u00ea deve escolher as melhores ferramentas. Um bom chefe gasta algumas horas escolhendo quais acess\u00f3rios ser\u00e3o necess\u00e1rios para a produ\u00e7\u00e3o do prato e j\u00e1 deixa na bancada de forma que n\u00e3o precise ficar procurando enquanto est\u00e1 produzindo seu prato. Na programa\u00e7\u00e3o tamb\u00e9m \u00e9 assim, escolhemos as ferramentas necess\u00e1rias para desenvolver, testar e colocar no ar nosso sistema. Para este curso foram escolhidas algumas ferramentas e a partir de agora iremos ver como instal\u00e1-las e configur\u00e1-las para que daqui pra frente n\u00e3o tenhamos que parar para fazer instala\u00e7\u00e3o de mais uma ferramenta. As ferramentas foram escolhidas pensando na did\u00e1tica do aluno assim como compatibilidade de sistemas operacionais e tamb\u00e9m por serem as principais escolhas no mercado de trabalho. Siga os passos de acordo com o seu sistema operacional para cada ferramenta. Tenha sempre certeza de que a ferramenta est\u00e1 instalada e funcionando. \ud83d\udd27 Git O que \u00e9? Git \u00e9 um controle de vers\u00e3o livre e de c\u00f3digo aberto, construido para lidar com projetos pequenos e grandes de maneira r\u00e1pida e eficiente. Para que serve? Com certeza voc\u00ea j\u00e1 escreveu um arquivo, mais tarde troca algumas coisas e salva como final. Mais tarde ou no outro dia voc\u00ea decide fazer mais mudan\u00e7as e chama de \"agoravai\" e quando menos percebe j\u00e1 tem um monte de arquivos e talvez nem se lembre mais qual a ultima vers\u00e3o. \u00c9 para gerenciar altera\u00e7\u00f5es feitas no projeto durante o tempo que serve esta ferramenta. Durante o curso vamos salvando cada progresso feito sem precisar de ter v\u00e1rias c\u00f3pias do mesmo arquivo. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac O pacote git se encontra na central de programas. sudo apt install git Baixe a \u00faltima vers\u00e3o neste site . Deixe as op\u00e7\u00f5es j\u00e1 marcadas por padr\u00e3o, exceto a mostrada abaixo que deve ser ajustada. O pacote git faz parte do kit de desenvolvimento Xcode. Para instalar, basta tentar usar o comando pela primeira vez. Opcionalmente, voc\u00ea pode entrar na App Store e procurar por Xcode. git --help Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1 Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1 Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1 \ud83d\udc0d Python O que \u00e9? Python \u00e9 uma linguagem de programa\u00e7\u00e3o com foco em legibilidade e produtividade, criada para escrever c\u00f3digo bom e f\u00e1cil de manter de maneira r\u00e1pida. Para que serve? \u00c9 uma linguagem bastante vers\u00e1til, e hoje em dia \u00e9 amplamente utilizada para escrever sistemas web, integra\u00e7\u00f5es entre sistemas, automatizar tarefas e muitas outras coisas. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Vers\u00f5es mais atuais do ubuntu j\u00e1 vem com o python 3 instalado, e inclusive, a partir da vers\u00e3o 17.10, essa passa a ser a vers\u00e3o padr\u00e3o do sistema. Caso python 3 n\u00e3o esteja instalado, utilize sudo apt install python3 . Baixe o instalador de acordo com o seu computador caso seja 64 bits ou 32 bits . Ap\u00f3s baixar o instalador fique atento para selecionar a op\u00e7\u00e3o marcada na figura abaixo. Para continuar a intala\u00e7\u00e3o clique em \"Install Now\". Assim como o Ubuntu (e outros sistemas Unix e \"Unix-Like\")o Mac OS tamb\u00e9m j\u00e1 vem com uma vers\u00e3o no Python instalada. Por\u00e9m, a vers\u00e3o dispon\u00edvel por padr\u00e3o no sistema est\u00e1 sempre muito defasada em reala\u00e7\u00e3o a \u00faltima vers\u00e3o est\u00e1vel dispon\u00edvel. Por exemplo, na data atual a vers\u00e3o 3.8 j\u00e1 foi lan\u00e7ada para o p\u00fablico, por\u00e9m o sistema ainda utiliza a vers\u00e3o 2.7. Para instalar a vers\u00e3o mais atual, a maneira convencional \u00e9 utilizar o gerenciador de pacotes Homebrew . Clique no link e veja como instal\u00e1-lo com um simples comando! Com ele instalado, basta utilizar o comando: brew install python no seu terminal. Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python --version Python 3 .10.4 Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python --version Python 3 .10.4 Abra um terminal e digite python3 --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 --version Python 3 .10.4 Warning A vers\u00e3o necess\u00e1ria neste curso \u00e9 acima da 3.7 devido a recursos que utilizaremos. \ud83d\ude9a Pip O que \u00e9? Pip \u00e9 o gerenciador de pacotes do python. \u00c9 um cliente de linha de comandos utilizado para controle das dep\u00eandencias do projeto. Para que serve? Utilizaremos o pip para controlar a vers\u00e3o das bibliotecas utilizadas para desenvolvimento do sistema. O pip nos permite baixar uma vers\u00e3o espec\u00edfica de uma biblioteca como por exemplo python3 -m pip install fastapi==0.43.0 . Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Esta ferramenta n\u00e3o vem por padr\u00e3o no sistema operacional ubuntu e pode ser instalada utilizando o comando sudo apt install python3-pip . N\u00e3o ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o pois o mesmo j\u00e1 vem com o instalador da linguagem. Se voc\u00ea instalou o Python utilizando o Homebrew, o pip j\u00e1 foi instalado em seu sistema. Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python3 -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 ) Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 ) Abra um terminal e digite python3 -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 ) \ud83d\udcda venv O que \u00e9? Respons\u00e1vel por criar ambientes virtuais Python e prov\u00ea um isolamento dos pacotes instalados e suas respectivas vers\u00f5es. \u00c9 um cliente de linha de comando que auxilia na separa\u00e7\u00e3o de ambientes para diferentes projetos. Para que serve? Iniciamos um projeto que tem uma biblioteca na vers\u00e3o 1.4 , e de repente, um novo projeto \u00e9 iniciado na vers\u00e3o 2.0 . O que fazer? Ser\u00e1 que s\u00e3o compat\u00edveis? E se eu atualizo o sitema e a vers\u00e3o antiga para de funcionar? \u00c9 onde o venv entra, ele serve para isolar ambientes entre projetos, ou seja, eu consigo ter dois projetos rodando, em dois ambientes diferentes, com vers\u00f5es diferentes da mesma biblioteca. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Vers\u00f5es atuais do ubuntu j\u00e1 vem com python 3 instalado. Para as mais antigas utilize o comando sudo apt install python3-venv . N\u00e3o ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o pois o mesmo j\u00e1 vem com o instalador da linguagem. Normalmente o venv \u00e9 instalado junto com o Python e com o pip ao utilizar o Homebrew. Se o comando de verifica\u00e7\u00e3o (logo abaixo) n\u00e3o funcionar, voc\u00ea pode instal\u00e1-lo utilizando o pr\u00f3prio pip com o comando pip install virtualenv Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python3 -m venv -h . Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -m venv -h . Abra um terminal e digite python3 -m venv -h . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m venv -h usage: venv [ -h ] [ --system-site-packages ] [ --symlinks | --copies ] [ --clear ] [ --upgrade ] [ --without-pip ] [ --prompt PROMPT ] ENV_DIR [ ENV_DIR ... ] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in . optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in -place. --without-pip Skips installing or upgrading pip in the virtual environment ( pip is bootstrapped by default ) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. \u2601\ufe0f Heroku CLI O que \u00e9? O Heroku \u00e9 uma plataforma em nuvem como um servi\u00e7o (PaaS) que suporta v\u00e1rias linguagens de programa\u00e7\u00e3o usadas como um modelo de implanta\u00e7\u00e3o de aplicativos da Web. A CLI \u00e9 uma interface de linha de comando que serve para facilitar a cria\u00e7\u00e3o e o gerenciamento de aplicativos direto do terminal. Para que serve? Vamos utilizar o heroku para colocar nossa aplica\u00e7\u00e3o no ar e se tudo der certo, automatizar este processo. O CLI vai ajudar a fazer isto atrav\u00e9s do terminal. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite wget -qO- https://cli-assets.heroku.com/install-ubuntu.sh | sh . V\u00e1 no site de download do heroku e baixe o instalador. Abra um terminal e digite brew tap heroku/brew && brew install heroku . Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite heroku --version . Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite heroku --version . Abra um terminal e digite heroku --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ heroku --version heroku/7.60.2 linux-x64 node-v18.0.0 \ud83c\udf89 Parab\u00e9ns! Instalamos todas as ferramentas que precisaremos para acompanhar este curso, vamos para o pr\u00f3ximo passo!","title":"\ud83d\udd28 Escolhendo as melhores ferramentas"},{"location":"ferramentas/#escolhendo-as-melhores-ferramentas","text":"","title":"\ud83d\udd28 Escolhendo as melhores ferramentas"},{"location":"ferramentas/#um-bom-chef-escolhe-as-melhores-ferramentas","text":"Uma analogia que normalmente fa\u00e7o \u00e9 que programar \u00e9 igual a cozinhar, voc\u00ea deve escolher as melhores ferramentas. Um bom chefe gasta algumas horas escolhendo quais acess\u00f3rios ser\u00e3o necess\u00e1rios para a produ\u00e7\u00e3o do prato e j\u00e1 deixa na bancada de forma que n\u00e3o precise ficar procurando enquanto est\u00e1 produzindo seu prato. Na programa\u00e7\u00e3o tamb\u00e9m \u00e9 assim, escolhemos as ferramentas necess\u00e1rias para desenvolver, testar e colocar no ar nosso sistema. Para este curso foram escolhidas algumas ferramentas e a partir de agora iremos ver como instal\u00e1-las e configur\u00e1-las para que daqui pra frente n\u00e3o tenhamos que parar para fazer instala\u00e7\u00e3o de mais uma ferramenta. As ferramentas foram escolhidas pensando na did\u00e1tica do aluno assim como compatibilidade de sistemas operacionais e tamb\u00e9m por serem as principais escolhas no mercado de trabalho. Siga os passos de acordo com o seu sistema operacional para cada ferramenta. Tenha sempre certeza de que a ferramenta est\u00e1 instalada e funcionando.","title":"\ud83c\udf74 Um bom chef escolhe as melhores ferramentas"},{"location":"ferramentas/#git","text":"O que \u00e9? Git \u00e9 um controle de vers\u00e3o livre e de c\u00f3digo aberto, construido para lidar com projetos pequenos e grandes de maneira r\u00e1pida e eficiente. Para que serve? Com certeza voc\u00ea j\u00e1 escreveu um arquivo, mais tarde troca algumas coisas e salva como final. Mais tarde ou no outro dia voc\u00ea decide fazer mais mudan\u00e7as e chama de \"agoravai\" e quando menos percebe j\u00e1 tem um monte de arquivos e talvez nem se lembre mais qual a ultima vers\u00e3o. \u00c9 para gerenciar altera\u00e7\u00f5es feitas no projeto durante o tempo que serve esta ferramenta. Durante o curso vamos salvando cada progresso feito sem precisar de ter v\u00e1rias c\u00f3pias do mesmo arquivo. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac O pacote git se encontra na central de programas. sudo apt install git Baixe a \u00faltima vers\u00e3o neste site . Deixe as op\u00e7\u00f5es j\u00e1 marcadas por padr\u00e3o, exceto a mostrada abaixo que deve ser ajustada. O pacote git faz parte do kit de desenvolvimento Xcode. Para instalar, basta tentar usar o comando pela primeira vez. Opcionalmente, voc\u00ea pode entrar na App Store e procurar por Xcode. git --help Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1 Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1 Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .36.1","title":"\ud83d\udd27 Git"},{"location":"ferramentas/#python","text":"O que \u00e9? Python \u00e9 uma linguagem de programa\u00e7\u00e3o com foco em legibilidade e produtividade, criada para escrever c\u00f3digo bom e f\u00e1cil de manter de maneira r\u00e1pida. Para que serve? \u00c9 uma linguagem bastante vers\u00e1til, e hoje em dia \u00e9 amplamente utilizada para escrever sistemas web, integra\u00e7\u00f5es entre sistemas, automatizar tarefas e muitas outras coisas. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Vers\u00f5es mais atuais do ubuntu j\u00e1 vem com o python 3 instalado, e inclusive, a partir da vers\u00e3o 17.10, essa passa a ser a vers\u00e3o padr\u00e3o do sistema. Caso python 3 n\u00e3o esteja instalado, utilize sudo apt install python3 . Baixe o instalador de acordo com o seu computador caso seja 64 bits ou 32 bits . Ap\u00f3s baixar o instalador fique atento para selecionar a op\u00e7\u00e3o marcada na figura abaixo. Para continuar a intala\u00e7\u00e3o clique em \"Install Now\". Assim como o Ubuntu (e outros sistemas Unix e \"Unix-Like\")o Mac OS tamb\u00e9m j\u00e1 vem com uma vers\u00e3o no Python instalada. Por\u00e9m, a vers\u00e3o dispon\u00edvel por padr\u00e3o no sistema est\u00e1 sempre muito defasada em reala\u00e7\u00e3o a \u00faltima vers\u00e3o est\u00e1vel dispon\u00edvel. Por exemplo, na data atual a vers\u00e3o 3.8 j\u00e1 foi lan\u00e7ada para o p\u00fablico, por\u00e9m o sistema ainda utiliza a vers\u00e3o 2.7. Para instalar a vers\u00e3o mais atual, a maneira convencional \u00e9 utilizar o gerenciador de pacotes Homebrew . Clique no link e veja como instal\u00e1-lo com um simples comando! Com ele instalado, basta utilizar o comando: brew install python no seu terminal. Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python --version Python 3 .10.4 Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python --version Python 3 .10.4 Abra um terminal e digite python3 --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 --version Python 3 .10.4 Warning A vers\u00e3o necess\u00e1ria neste curso \u00e9 acima da 3.7 devido a recursos que utilizaremos.","title":"\ud83d\udc0d Python"},{"location":"ferramentas/#pip","text":"O que \u00e9? Pip \u00e9 o gerenciador de pacotes do python. \u00c9 um cliente de linha de comandos utilizado para controle das dep\u00eandencias do projeto. Para que serve? Utilizaremos o pip para controlar a vers\u00e3o das bibliotecas utilizadas para desenvolvimento do sistema. O pip nos permite baixar uma vers\u00e3o espec\u00edfica de uma biblioteca como por exemplo python3 -m pip install fastapi==0.43.0 . Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Esta ferramenta n\u00e3o vem por padr\u00e3o no sistema operacional ubuntu e pode ser instalada utilizando o comando sudo apt install python3-pip . N\u00e3o ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o pois o mesmo j\u00e1 vem com o instalador da linguagem. Se voc\u00ea instalou o Python utilizando o Homebrew, o pip j\u00e1 foi instalado em seu sistema. Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python3 -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 ) Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 ) Abra um terminal e digite python3 -m pip --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m pip --version pip 22 .0.4 from /usr/lib/python3.10/site-packages ( python 3 .10 )","title":"\ud83d\ude9a Pip"},{"location":"ferramentas/#venv","text":"O que \u00e9? Respons\u00e1vel por criar ambientes virtuais Python e prov\u00ea um isolamento dos pacotes instalados e suas respectivas vers\u00f5es. \u00c9 um cliente de linha de comando que auxilia na separa\u00e7\u00e3o de ambientes para diferentes projetos. Para que serve? Iniciamos um projeto que tem uma biblioteca na vers\u00e3o 1.4 , e de repente, um novo projeto \u00e9 iniciado na vers\u00e3o 2.0 . O que fazer? Ser\u00e1 que s\u00e3o compat\u00edveis? E se eu atualizo o sitema e a vers\u00e3o antiga para de funcionar? \u00c9 onde o venv entra, ele serve para isolar ambientes entre projetos, ou seja, eu consigo ter dois projetos rodando, em dois ambientes diferentes, com vers\u00f5es diferentes da mesma biblioteca. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Vers\u00f5es atuais do ubuntu j\u00e1 vem com python 3 instalado. Para as mais antigas utilize o comando sudo apt install python3-venv . N\u00e3o ser\u00e1 necess\u00e1rio a instala\u00e7\u00e3o pois o mesmo j\u00e1 vem com o instalador da linguagem. Normalmente o venv \u00e9 instalado junto com o Python e com o pip ao utilizar o Homebrew. Se o comando de verifica\u00e7\u00e3o (logo abaixo) n\u00e3o funcionar, voc\u00ea pode instal\u00e1-lo utilizando o pr\u00f3prio pip com o comando pip install virtualenv Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite python3 -m venv -h . Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -m venv -h . Abra um terminal e digite python3 -m venv -h . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ python3 -m venv -h usage: venv [ -h ] [ --system-site-packages ] [ --symlinks | --copies ] [ --clear ] [ --upgrade ] [ --without-pip ] [ --prompt PROMPT ] ENV_DIR [ ENV_DIR ... ] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in . optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in -place. --without-pip Skips installing or upgrading pip in the virtual environment ( pip is bootstrapped by default ) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory.","title":"\ud83d\udcda venv"},{"location":"ferramentas/#heroku-cli","text":"O que \u00e9? O Heroku \u00e9 uma plataforma em nuvem como um servi\u00e7o (PaaS) que suporta v\u00e1rias linguagens de programa\u00e7\u00e3o usadas como um modelo de implanta\u00e7\u00e3o de aplicativos da Web. A CLI \u00e9 uma interface de linha de comando que serve para facilitar a cria\u00e7\u00e3o e o gerenciamento de aplicativos direto do terminal. Para que serve? Vamos utilizar o heroku para colocar nossa aplica\u00e7\u00e3o no ar e se tudo der certo, automatizar este processo. O CLI vai ajudar a fazer isto atrav\u00e9s do terminal. Como instalar \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite wget -qO- https://cli-assets.heroku.com/install-ubuntu.sh | sh . V\u00e1 no site de download do heroku e baixe o instalador. Abra um terminal e digite brew tap heroku/brew && brew install heroku . Vamos verificar se deu tudo certo? \ud83d\udc27 Ubuntu \ud83d\udda5\ufe0f Windows \ud83c\udf4e Mac Abra um terminal e digite heroku --version . Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite heroku --version . Abra um terminal e digite heroku --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ heroku --version heroku/7.60.2 linux-x64 node-v18.0.0","title":"\u2601\ufe0f Heroku CLI"},{"location":"ferramentas/#parabens","text":"Instalamos todas as ferramentas que precisaremos para acompanhar este curso, vamos para o pr\u00f3ximo passo!","title":"\ud83c\udf89 Parab\u00e9ns!"},{"location":"hello_fastapi/","text":"\u26a1 Hello FastAPI \u00c9 chegada a t\u00e3o esperada hora de escrevermos c\u00f3digo, por\u00e9m, como aprendemos que podemos ser guiados por testes para ajudar a concep\u00e7\u00e3o da arquitetura do nosso programa, faremos as coisas um pouco diferente. Utilizaremos os ciclos do TDD para nos auxiliarem e assim garantiremos uma qualidade de c\u00f3digo ao final. Est\u00e3o lembrados o que \u00e9 a nossa aplica\u00e7\u00e3o? Caso n\u00e3o se recorde leia as regras de neg\u00f3cio novamente. Vamos dividir algumas tarefas ent\u00e3o, na nossa lista de funcionalidades: listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada Acho que para iniciarmos o mais simples de escrever e testar \u00e9 a funcionalidade de listagem de tarefas. Mas como fazer isto se n\u00e3o temos tarefas, nem mesmo uma aplica\u00e7\u00e3o ainda? Por onde come\u00e7o? Inicie criando um diret\u00f3rio com o nome tests , onde colocaremos os testes do nosso programa. L\u00e1 dentro, crie um arquivo com nome test_gerenciador.py que deve ficar da seguinte maneira. . \u251c\u2500\u2500 dev-requirements.txt \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_gerenciador.py Agora vamos escrever nosso primeiro teste! Nossa listagem de tarefas, se bem sucedida, deve retornar o c\u00f3digo de status 200 OK e este ser\u00e1 nosso primeiro teste. Traduzindo em um teste automatizado que deve ser acrescentado ao arquivo test_gerenciador.py. from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas import app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK Vamos rodar pela primeira vez os testes no nosso projeto. python -m pytest \ud83d\ude31 Nossa! Ocorreu um erro! $ python -m pytest ========================================================= test session starts ========================================================= platform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 rootdir: /home/cassiobotaro/Projects/gerenciador-tarefas plugins: anyio-3.6.1 collected 0 items / 1 error =============================================================== ERRORS ================================================================ _____________________________________________ ERROR collecting tests/test_gerenciador.py ______________________________________________ ImportError while importing test module '/home/cassiobotaro/Projects/gerenciador-tarefas/tests/test_gerenciador.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: ../../.asdf/installs/python/3.10.4/lib/python3.10/importlib/__init__.py:126: in import_module return _bootstrap._gcd_import(name[level:], package, level) tests/test_gerenciador.py:3: in <module> from gerenciador_tarefas.gerenciador import app E ModuleNotFoundError: No module named 'gerenciador_tarefas.gerenciador' ======================================================= short test summary info ======================================================= ERROR tests/test_gerenciador.py !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ========================================================== 1 error in 0.30s =========================================================== N\u00e3o se desespere, \u00e9 que temos um teste, mas ainda n\u00e3o come\u00e7amos a escrever c\u00f3digo da nossa aplica\u00e7\u00e3o. A primeira coisa que precisamos fazer \u00e9 criar um diret\u00f3rio onde colocaremos nossos c\u00f3digos. vamos chama-lo de gerenciador_tarefas . Dentro dele criamos um novo arquivo gerenciador.py , e neste arquivo vamos iniciar uma aplica\u00e7\u00e3o da seguinte maneira. . \u251c\u2500\u2500 dev-requirements.txt \u251c\u2500\u2500 gerenciador_tarefas \u2502 \u2514\u2500\u2500 gerenciador.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_gerenciador.py O conte\u00fado desse arquivo ser\u00e1 o seguinte. from fastapi import FastAPI app = FastAPI () Isto \u00e9 uma maneira de fazer os testes conhecerem o c\u00f3digo da nossa aplica\u00e7\u00e3o. Toda vez que precisamos de um trecho de c\u00f3digo em outro arquivo devemos fazer a \"importa\u00e7\u00e3o\" daquele trecho utilizando o comando import. Neste caso estamos requisitando a aplica\u00e7\u00e3o nos arquivos de testes automatizados, para escrevermos os testes necess\u00e1rios. Rode novamente os testes. python -m pytest \u274c Os testes continuam falhando! # ... > assert resposta . status_code == status . HTTP_200_OK E assert 404 == 200 E + where 404 = < Response [ 404 ] >. status_code E + and 200 = status . HTTP_200_OK # ... O teste est\u00e1 dizendo que esper\u00e1mos um c\u00f3digo de status de sucesso, por\u00e9m o recurso ( tarefas ) n\u00e3o foi encontrado, por isso o c\u00f3digo 404. Agora temos nossa aplica\u00e7\u00e3o, mas nosso recurso de tarefas ainda n\u00e3o foi criado. No arquivo gerenciador.py adicione a seguinte fun\u00e7\u00e3o. @app . get ( \"/tarefas\" ) def listar (): return \"\" Rode novamente os testes. python -m pytest $ python - m pytest ========================================================= test session starts ========================================================= platform linux -- Python 3.10.4 , pytest - 7.1.2 , pluggy - 1.0.0 rootdir : / home / cassiobotaro / Projects / gerenciador - tarefas plugins : anyio - 3.6.1 collected 1 item tests / test_gerenciador . py . [ 100 % ] ========================================================== 1 passed in 0.23 s ========================================================== \u2705 Legal! Temos um teste funcionando! Nossa aplica\u00e7\u00e3o est\u00e1 retornando status 200 OK, ainda que a funcionalidade completa n\u00e3o esteja pronta. \ud83d\udc76 Damos o nome de baby step , esta maneira de construir uma aplica\u00e7\u00e3o dando pequenos passos de cada vez. Nosso recurso deve ter o formato json , que \u00e9 um formato textual estruturado, bem simples e leve para troca de informa\u00e7\u00f5es. Mas como checamos isto? Vamos escrever um novo teste! No arquivo test_gerenciador.py , adicione o seguinte teste. def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" Rode os testes novamente. Caso esque\u00e7a o comando, volte um pouco atr\u00e1s e copie. Uai? O novo teste est\u00e1 passando ?!?! Acontece que por padr\u00e3o, o fastapi j\u00e1 define que o formato ser\u00e1 \"json\". Normalmente, queremos que testes falhem, por\u00e9m este teste pode ser \u00fatil como documenta\u00e7\u00e3o do seu recurso. Vamos deixa-lo e vamos seguir em frente, mas agora tentando escrever um teste que realmente falhe. Quando listar tarefas o retorno deve possuir o formato de lista. Transformando isto em c\u00f3digo temos: def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) E vamos continuar o nosso ciclo e rodar os testes. \u274c O teste falha e isto \u00e9 bom! Acontece que nosso retorno n\u00e3o \u00e9 uma lista. Mas como corrigir isto? Se temos um teste que falha, precisamos escrever o c\u00f3digo necess\u00e1rio para este teste passar. Vamos voltar ao nosso gerenciador.py para corrigir o nosso problema. Na fun\u00e7\u00e3o que exp\u00f5e o nosso recurso, modifique o c\u00f3digo para: @app . get ( \"/tarefas\" ) def listar (): return [] Corrigido o c\u00f3digo, rode novamente os testes. \u2705 Aew! Testes est\u00e3o passando novamente! Neste passo os arquivos devem estar da seguinte maneira. test_gerenciador.py from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas.gerenciador import app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) gerenciador.py from fastapi import FastAPI app = FastAPI () @app . get ( \"/tarefas\" ) def listar (): return [] Repare que pouco a pouco nossa aplica\u00e7\u00e3o vai tomando forma a partir dos testes. Parece chato ter de ficar rodando os testes a cada vez, mas al\u00e9m de garatir a qualidade do c\u00f3digo, cada vez que os testes s\u00e3o rodados, todas as funcionalidades testadas anteriormente s\u00e3o verificadas novamente. Assim voc\u00ea evita ter de lembrar todas as possibilidades a serem testadas em um teste manual. \ud83d\udea6 Perceberam que estamos guiando o nosso desenvolvimento a partir dos testes? Pouco a pouco temos a funcionalidade de listagem sendo desenhada. Vamos continuar ent\u00e3o. Sabemos que quando n\u00e3o h\u00e1 tarefas, nossa resposta do recurso deve ser uma lista vazia. Mas e quando a lista de tarefas possuir conte\u00fado? Qual o retorno esperado? Vamos criar uma lista de tarefas, adicionaremos conte\u00fado a ela e este conte\u00fado deve ser retornado. Para fazermos esta checagem, vamos pegar uma tarefa da lista e verificar os seus campos. O teste automatizado para isto pode ser escrito da seguinte maneira. def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () \u274c Rodou os testes? Pois \u00e9, est\u00e3o quebrando novamente pois TAREFAS n\u00e3o foi definido. Vamos l\u00e1 no arquivo gerenciador.py e defini-lo. # ... TAREFAS = {} # ... Info N\u00e3o esque\u00e7a de ir no arquivo de testes e importar TAREFAS do gerenciador from gerenciador_tarefas.gerenciador import app, TAREFAS \u274c Os testes ainda est\u00e3o quebrando? Sim, mas agora o erro \u00e9 outro. O erro mostrado \u00e9 IndexError: pop from empty list , e isto ocorre porque l\u00e1 no gerenciador ainda estamos retornando uma lista vazia e n\u00e3o a lista de tarefas. Vamos modificar isto como abaixo: @app . get ( \"/tarefas\" ) def listar (): return TAREFAS Repita este processo para cada um dos campos de uma tarefa, ent\u00e3o teremos que verificar titulo, descri\u00e7\u00e3o e o estado da tarefa. No fim nos testes ficam: from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas.gerenciador import app , TAREFAS def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_titulo (): TAREFAS . append ({ \"titulo\" : \"titulo 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"titulo\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_descricao (): TAREFAS . append ({ \"descricao\" : \"descricao 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"descricao\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_um_estado (): TAREFAS . append ({ \"estado\" : \"finalizado\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"estado\" in resposta . json () . pop () TAREFAS . clear () E nosso c\u00f3digo: from fastapi import FastAPI app = FastAPI () TAREFAS = [] @app . get ( \"/tarefas\" ) def listar (): return TAREFAS \u2705 Os testes est\u00e3o funcionando? Parab\u00e9ns! \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f \ud83d\udd27 Testando manualmente Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. O comando para isto \u00e9 uvicorn --reload gerenciador_tarefas.gerenciador:app . Voil\u00e0, sua aplica\u00e7\u00e3o est\u00e1 no ar. Clique aqui para abrir no navegador. Como adicionamos a op\u00e7\u00e3o --reload , cada vez que modificamos o c\u00f3digo, o resultado \u00e9 modificado tamb\u00e9m, sem precisar desligar e rodar de novo a aplica\u00e7\u00e3o. Experimente adicionar tarefas na lista. TAREFAS = [ { \"id\" : \"1\" , \"titulo\" : \"fazer compras\" , \"descri\u00e7\u00e3o\" : \"comprar leite e ovos\" , \"estado\" : \"n\u00e3o finalizado\" , }, { \"id\" : \"2\" , \"titulo\" : \"levar o cachorro para tosar\" , \"descri\u00e7\u00e3o\" : \"est\u00e1 muito peludo\" , \"estado\" : \"n\u00e3o finalizado\" , }, { \"id\" : \"3\" , \"titulo\" : \"lavar roupas\" , \"descri\u00e7\u00e3o\" : \"est\u00e3o sujas\" , \"estado\" : \"n\u00e3o finalizado\" , }, ] Uma outra op\u00e7\u00e3o \u00e9 navegar na sua aplica\u00e7\u00e3o atrav\u00e9s da documenta\u00e7\u00e3o que \u00e9 gerada automaticamente. Salvando a vers\u00e3o atual do c\u00f3digo Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) gerenciador_tarefas/ tests/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois diret\u00f3rios n\u00e3o rastreados e precisamos avisar ao controle de vers\u00e3o para monitora-los. $ git add gerenciador_tarefas tests \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona recurso de listar tarefas\" \ud83d\udd27 Por fim envie ao GitHub a vers\u00e3o atualizada do projeto. git push \ud83d\ude0e Parab\u00e9ns! Sua aplica\u00e7\u00e3o est\u00e1 tomando forma! J\u00e1 pensou se toda vez que envi\u00e1ssemos uma nova vers\u00e3o para o GitHub, ele verificasse para mim se os testes est\u00e3o passando? Vamos aprender a ter integra\u00e7\u00e3o cont\u00ednua de c\u00f3digo!?","title":"\u26a1\ufe0f Hello Fastapi"},{"location":"hello_fastapi/#hello-fastapi","text":"\u00c9 chegada a t\u00e3o esperada hora de escrevermos c\u00f3digo, por\u00e9m, como aprendemos que podemos ser guiados por testes para ajudar a concep\u00e7\u00e3o da arquitetura do nosso programa, faremos as coisas um pouco diferente. Utilizaremos os ciclos do TDD para nos auxiliarem e assim garantiremos uma qualidade de c\u00f3digo ao final. Est\u00e3o lembrados o que \u00e9 a nossa aplica\u00e7\u00e3o? Caso n\u00e3o se recorde leia as regras de neg\u00f3cio novamente. Vamos dividir algumas tarefas ent\u00e3o, na nossa lista de funcionalidades: listar as tarefas adicionar tarefa remover tarefa ordenar a listagem por estado finalizar uma tarefa exibir uma tarefa de forma detalhada Acho que para iniciarmos o mais simples de escrever e testar \u00e9 a funcionalidade de listagem de tarefas. Mas como fazer isto se n\u00e3o temos tarefas, nem mesmo uma aplica\u00e7\u00e3o ainda? Por onde come\u00e7o? Inicie criando um diret\u00f3rio com o nome tests , onde colocaremos os testes do nosso programa. L\u00e1 dentro, crie um arquivo com nome test_gerenciador.py que deve ficar da seguinte maneira. . \u251c\u2500\u2500 dev-requirements.txt \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_gerenciador.py Agora vamos escrever nosso primeiro teste! Nossa listagem de tarefas, se bem sucedida, deve retornar o c\u00f3digo de status 200 OK e este ser\u00e1 nosso primeiro teste. Traduzindo em um teste automatizado que deve ser acrescentado ao arquivo test_gerenciador.py. from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas import app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK Vamos rodar pela primeira vez os testes no nosso projeto. python -m pytest \ud83d\ude31 Nossa! Ocorreu um erro! $ python -m pytest ========================================================= test session starts ========================================================= platform linux -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0 rootdir: /home/cassiobotaro/Projects/gerenciador-tarefas plugins: anyio-3.6.1 collected 0 items / 1 error =============================================================== ERRORS ================================================================ _____________________________________________ ERROR collecting tests/test_gerenciador.py ______________________________________________ ImportError while importing test module '/home/cassiobotaro/Projects/gerenciador-tarefas/tests/test_gerenciador.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: ../../.asdf/installs/python/3.10.4/lib/python3.10/importlib/__init__.py:126: in import_module return _bootstrap._gcd_import(name[level:], package, level) tests/test_gerenciador.py:3: in <module> from gerenciador_tarefas.gerenciador import app E ModuleNotFoundError: No module named 'gerenciador_tarefas.gerenciador' ======================================================= short test summary info ======================================================= ERROR tests/test_gerenciador.py !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ========================================================== 1 error in 0.30s =========================================================== N\u00e3o se desespere, \u00e9 que temos um teste, mas ainda n\u00e3o come\u00e7amos a escrever c\u00f3digo da nossa aplica\u00e7\u00e3o. A primeira coisa que precisamos fazer \u00e9 criar um diret\u00f3rio onde colocaremos nossos c\u00f3digos. vamos chama-lo de gerenciador_tarefas . Dentro dele criamos um novo arquivo gerenciador.py , e neste arquivo vamos iniciar uma aplica\u00e7\u00e3o da seguinte maneira. . \u251c\u2500\u2500 dev-requirements.txt \u251c\u2500\u2500 gerenciador_tarefas \u2502 \u2514\u2500\u2500 gerenciador.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_gerenciador.py O conte\u00fado desse arquivo ser\u00e1 o seguinte. from fastapi import FastAPI app = FastAPI () Isto \u00e9 uma maneira de fazer os testes conhecerem o c\u00f3digo da nossa aplica\u00e7\u00e3o. Toda vez que precisamos de um trecho de c\u00f3digo em outro arquivo devemos fazer a \"importa\u00e7\u00e3o\" daquele trecho utilizando o comando import. Neste caso estamos requisitando a aplica\u00e7\u00e3o nos arquivos de testes automatizados, para escrevermos os testes necess\u00e1rios. Rode novamente os testes. python -m pytest \u274c Os testes continuam falhando! # ... > assert resposta . status_code == status . HTTP_200_OK E assert 404 == 200 E + where 404 = < Response [ 404 ] >. status_code E + and 200 = status . HTTP_200_OK # ... O teste est\u00e1 dizendo que esper\u00e1mos um c\u00f3digo de status de sucesso, por\u00e9m o recurso ( tarefas ) n\u00e3o foi encontrado, por isso o c\u00f3digo 404. Agora temos nossa aplica\u00e7\u00e3o, mas nosso recurso de tarefas ainda n\u00e3o foi criado. No arquivo gerenciador.py adicione a seguinte fun\u00e7\u00e3o. @app . get ( \"/tarefas\" ) def listar (): return \"\" Rode novamente os testes. python -m pytest $ python - m pytest ========================================================= test session starts ========================================================= platform linux -- Python 3.10.4 , pytest - 7.1.2 , pluggy - 1.0.0 rootdir : / home / cassiobotaro / Projects / gerenciador - tarefas plugins : anyio - 3.6.1 collected 1 item tests / test_gerenciador . py . [ 100 % ] ========================================================== 1 passed in 0.23 s ========================================================== \u2705 Legal! Temos um teste funcionando! Nossa aplica\u00e7\u00e3o est\u00e1 retornando status 200 OK, ainda que a funcionalidade completa n\u00e3o esteja pronta. \ud83d\udc76 Damos o nome de baby step , esta maneira de construir uma aplica\u00e7\u00e3o dando pequenos passos de cada vez. Nosso recurso deve ter o formato json , que \u00e9 um formato textual estruturado, bem simples e leve para troca de informa\u00e7\u00f5es. Mas como checamos isto? Vamos escrever um novo teste! No arquivo test_gerenciador.py , adicione o seguinte teste. def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" Rode os testes novamente. Caso esque\u00e7a o comando, volte um pouco atr\u00e1s e copie. Uai? O novo teste est\u00e1 passando ?!?! Acontece que por padr\u00e3o, o fastapi j\u00e1 define que o formato ser\u00e1 \"json\". Normalmente, queremos que testes falhem, por\u00e9m este teste pode ser \u00fatil como documenta\u00e7\u00e3o do seu recurso. Vamos deixa-lo e vamos seguir em frente, mas agora tentando escrever um teste que realmente falhe. Quando listar tarefas o retorno deve possuir o formato de lista. Transformando isto em c\u00f3digo temos: def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) E vamos continuar o nosso ciclo e rodar os testes. \u274c O teste falha e isto \u00e9 bom! Acontece que nosso retorno n\u00e3o \u00e9 uma lista. Mas como corrigir isto? Se temos um teste que falha, precisamos escrever o c\u00f3digo necess\u00e1rio para este teste passar. Vamos voltar ao nosso gerenciador.py para corrigir o nosso problema. Na fun\u00e7\u00e3o que exp\u00f5e o nosso recurso, modifique o c\u00f3digo para: @app . get ( \"/tarefas\" ) def listar (): return [] Corrigido o c\u00f3digo, rode novamente os testes. \u2705 Aew! Testes est\u00e3o passando novamente! Neste passo os arquivos devem estar da seguinte maneira. test_gerenciador.py from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas.gerenciador import app def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) gerenciador.py from fastapi import FastAPI app = FastAPI () @app . get ( \"/tarefas\" ) def listar (): return [] Repare que pouco a pouco nossa aplica\u00e7\u00e3o vai tomando forma a partir dos testes. Parece chato ter de ficar rodando os testes a cada vez, mas al\u00e9m de garatir a qualidade do c\u00f3digo, cada vez que os testes s\u00e3o rodados, todas as funcionalidades testadas anteriormente s\u00e3o verificadas novamente. Assim voc\u00ea evita ter de lembrar todas as possibilidades a serem testadas em um teste manual. \ud83d\udea6 Perceberam que estamos guiando o nosso desenvolvimento a partir dos testes? Pouco a pouco temos a funcionalidade de listagem sendo desenhada. Vamos continuar ent\u00e3o. Sabemos que quando n\u00e3o h\u00e1 tarefas, nossa resposta do recurso deve ser uma lista vazia. Mas e quando a lista de tarefas possuir conte\u00fado? Qual o retorno esperado? Vamos criar uma lista de tarefas, adicionaremos conte\u00fado a ela e este conte\u00fado deve ser retornado. Para fazermos esta checagem, vamos pegar uma tarefa da lista e verificar os seus campos. O teste automatizado para isto pode ser escrito da seguinte maneira. def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () \u274c Rodou os testes? Pois \u00e9, est\u00e3o quebrando novamente pois TAREFAS n\u00e3o foi definido. Vamos l\u00e1 no arquivo gerenciador.py e defini-lo. # ... TAREFAS = {} # ... Info N\u00e3o esque\u00e7a de ir no arquivo de testes e importar TAREFAS do gerenciador from gerenciador_tarefas.gerenciador import app, TAREFAS \u274c Os testes ainda est\u00e3o quebrando? Sim, mas agora o erro \u00e9 outro. O erro mostrado \u00e9 IndexError: pop from empty list , e isto ocorre porque l\u00e1 no gerenciador ainda estamos retornando uma lista vazia e n\u00e3o a lista de tarefas. Vamos modificar isto como abaixo: @app . get ( \"/tarefas\" ) def listar (): return TAREFAS Repita este processo para cada um dos campos de uma tarefa, ent\u00e3o teremos que verificar titulo, descri\u00e7\u00e3o e o estado da tarefa. No fim nos testes ficam: from fastapi.testclient import TestClient from fastapi import status from gerenciador_tarefas.gerenciador import app , TAREFAS def test_quando_listar_tarefas_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . status_code == status . HTTP_200_OK def test_quando_listar_tarefas_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_listar_tarefas_retorno_deve_ser_uma_lista (): cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert isinstance ( resposta . json (), list ) def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_id (): TAREFAS . append ({ \"id\" : 1 }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"id\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_titulo (): TAREFAS . append ({ \"titulo\" : \"titulo 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"titulo\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_descricao (): TAREFAS . append ({ \"descricao\" : \"descricao 1\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"descricao\" in resposta . json () . pop () TAREFAS . clear () def test_quando_listar_tarefas_a_tarefa_retornada_deve_possuir_um_estado (): TAREFAS . append ({ \"estado\" : \"finalizado\" }) cliente = TestClient ( app ) resposta = cliente . get ( \"/tarefas\" ) assert \"estado\" in resposta . json () . pop () TAREFAS . clear () E nosso c\u00f3digo: from fastapi import FastAPI app = FastAPI () TAREFAS = [] @app . get ( \"/tarefas\" ) def listar (): return TAREFAS \u2705 Os testes est\u00e3o funcionando? Parab\u00e9ns! \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f","title":"\u26a1 Hello FastAPI"},{"location":"hello_fastapi/#testando-manualmente","text":"Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. O comando para isto \u00e9 uvicorn --reload gerenciador_tarefas.gerenciador:app . Voil\u00e0, sua aplica\u00e7\u00e3o est\u00e1 no ar. Clique aqui para abrir no navegador. Como adicionamos a op\u00e7\u00e3o --reload , cada vez que modificamos o c\u00f3digo, o resultado \u00e9 modificado tamb\u00e9m, sem precisar desligar e rodar de novo a aplica\u00e7\u00e3o. Experimente adicionar tarefas na lista. TAREFAS = [ { \"id\" : \"1\" , \"titulo\" : \"fazer compras\" , \"descri\u00e7\u00e3o\" : \"comprar leite e ovos\" , \"estado\" : \"n\u00e3o finalizado\" , }, { \"id\" : \"2\" , \"titulo\" : \"levar o cachorro para tosar\" , \"descri\u00e7\u00e3o\" : \"est\u00e1 muito peludo\" , \"estado\" : \"n\u00e3o finalizado\" , }, { \"id\" : \"3\" , \"titulo\" : \"lavar roupas\" , \"descri\u00e7\u00e3o\" : \"est\u00e3o sujas\" , \"estado\" : \"n\u00e3o finalizado\" , }, ] Uma outra op\u00e7\u00e3o \u00e9 navegar na sua aplica\u00e7\u00e3o atrav\u00e9s da documenta\u00e7\u00e3o que \u00e9 gerada automaticamente.","title":"\ud83d\udd27 Testando manualmente"},{"location":"hello_fastapi/#salvando-a-versao-atual-do-codigo","text":"Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) gerenciador_tarefas/ tests/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois diret\u00f3rios n\u00e3o rastreados e precisamos avisar ao controle de vers\u00e3o para monitora-los. $ git add gerenciador_tarefas tests \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona recurso de listar tarefas\" \ud83d\udd27 Por fim envie ao GitHub a vers\u00e3o atualizada do projeto. git push \ud83d\ude0e Parab\u00e9ns! Sua aplica\u00e7\u00e3o est\u00e1 tomando forma! J\u00e1 pensou se toda vez que envi\u00e1ssemos uma nova vers\u00e3o para o GitHub, ele verificasse para mim se os testes est\u00e3o passando? Vamos aprender a ter integra\u00e7\u00e3o cont\u00ednua de c\u00f3digo!?","title":"Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"integracao/","text":"\u2705 Integra\u00e7\u00e3o cont\u00ednua Conceito O desenvolvedor integra o c\u00f3digo alterado e/ou desenvolvido ao projeto principal na mesma frequ\u00eancia com que as funcionalidades s\u00e3o desenvolvidas, sendo feito muitas vezes. Todo o nosso projeto ser\u00e1 constru\u00eddo utilizando testes automatizados, e sempre rodaremos os testes localmente. Mas como garantir que minha altera\u00e7\u00e3o n\u00e3o impacta com o restante do projeto, ter isto de forma simples e automatizada? Como garantir que a qualidade do c\u00f3digo foi mantida? Utilizaremos o servi\u00e7o GitHub Actions para checar que nosso c\u00f3digo n\u00e3o quebra a \"build\", ou seja, quando integrado o novo c\u00f3digo ao sistema, todo o sistema continua funcional. Basicamente, a grande vantagem da integra\u00e7\u00e3o cont\u00ednua est\u00e1 no feedback instant\u00e2neo. Isso funciona da seguinte forma: a cada commit no reposit\u00f3rio, o build \u00e9 feito automaticamente, com todos os testes sendo executados de forma autom\u00e1tica e falhas sendo detectadas. Se algum commit n\u00e3o compilar ou quebrar qualquer um dos testes, a equipe toma conhecimento instant\u00e2neamente (atrav\u00e9s de email, por exemplo, indicando as falhas e o commit causador das mesmas). A equipe pode ent\u00e3o corrigir o problema o mais r\u00e1pido poss\u00edvel, o que \u00e9 fundamental para n\u00e3o introduzir erros ao criar novas funcionalidades, refatorar, etc. Integra\u00e7\u00e3o cont\u00ednua \u00e9 mais uma forma de trazer seguran\u00e7a em rela\u00e7\u00e3o a mudan\u00e7as: voc\u00ea pode fazer modifica\u00e7\u00f5es sem medo, pois ser\u00e1 avisado caso algo saia do esperado. Ferramentas Vamos instalar algumas ferramentas para nos ajudarem a terem um c\u00f3digo bem organizado e testado. \ud83d\udd20 isort O que \u00e9? isort \u00e9 uma ferramenta que ordena de forma alfab\u00e9tica as importa\u00e7\u00f5es, separando as bilbiotecas que s\u00e3o padr\u00f5es da linguagem, as externas ao sistema e as nativas do pr\u00f3prio sistema. Para que serve? O isort ir\u00e1 modificar o seu c\u00f3digo ordenando as importa\u00e7\u00f5es alfab\u00e9ticamente. Dessa forma, o bloco de importa\u00e7\u00f5es fica organizado e padronizado no projeto. Como instalar Execute o comando abaixo: python -m pip install isort Configura\u00e7\u00e3o Precisamos adicionar no arquivo pyproject.toml (voc\u00ea deve cria-lo) a seguinte configura\u00e7\u00e3o [tool.isort] profile = \"black\" line_length = 79 Assim evitamos um conflito com a ferramenta black e isort . Como executar python -m isort . \u2728 Black O que \u00e9? Black \u00e9 o formatador de c\u00f3digo Python intransigente. Ao us\u00e1-lo, voc\u00ea concorda em ceder o controle sobre as min\u00facias da formata\u00e7\u00e3o manual. Em troca, o black d\u00e1 a voc\u00ea velocidade, determinismo e liberdade do irritante pycodestyle sobre formata\u00e7\u00e3o. Voc\u00ea economizar\u00e1 tempo e energia mental para assuntos mais importantes. Para que serve? O black \u00e9 um formatador autom\u00e1tico de c\u00f3digo, ele ir\u00e1 modificar o seu c\u00f3digo seguindo o guia de estilo do Python. Iremos configur\u00e1-lo junto ao nosso editor para que a formata\u00e7\u00e3o seja feita atrav\u00e9s de um atalho do teclado como shift + ctrl + i. Como instalar Execute o comando abaixo: python -m pip install black Configura\u00e7\u00e3o Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.black] line-length = 79 Como executar python -m black . Assim evitamos um conflito com a ferramenta flake8 . \ud83c\udfa8 Flake8 O que \u00e9? Flake8 \u00e9 um programa de linha de comando que verifica seu c\u00f3digo e busca por erros ou formata\u00e7\u00f5es que n\u00e3o seguem o guia de estilo padr\u00e3o do python, conhecido como PEP-8 . Al\u00e9m disso tamb\u00e9m verifica a complexidade ciclom\u00e1tica do seu c\u00f3digo. Para que serve? \u00c9 muito comum cometermos alguns erros de sintaxe, principalmente quando ainda estamos nos familiarizando com uma linguagem nova. Assim como durante o nosso dia a dia podemos esquecer algum c\u00f3digo n\u00e3o utilizado. Esta ferramenta vai analisar o seu c\u00f3digo e procurar poss\u00edveis erros, evitando assim que s\u00f3 ocorram no momento em que o c\u00f3digo for executado. Esta ferramenta tamb\u00e9m aponta poss\u00edveis linhas que n\u00e3o est\u00e3o seguindo o estilo de c\u00f3digo definido para a linguagem python. Outra coisa bem comum quando estamos escrevendo c\u00f3digo \u00e9 que uma parte dele come\u00e7a a se tornar t\u00e3o complexa que h\u00e1 n caminhos por onde seu algoritmo pode seguir. Normalmente isto indica que devemos modificar o c\u00f3digo para torn\u00e1-lo mais simples e leg\u00edvel. O Flake8 ir\u00e1 apontar qual parte do seu c\u00f3digo est\u00e1 complexa e que deve ser modificada. Esta ferramenta ser\u00e1 integrada ao editor, dessa maneira, ao salvar o arquivo, teremos os erros encontrados apontados diretamente no mesmo. Como instalar Execute o comando abaixo: python -m pip install flake8 Como executar python -m flake8 --exclude=.venv \u2139\ufe0f Pode ser necess\u00e1rio a interven\u00e7\u00f5es manuais para que o c\u00f3digo seja corrigido. \ud83d\udd75\ufe0fpre-commit (Men\u00e7\u00e3o honrosa \ud83c\udfc5) Existem ferramentas que podem executar algum comando antes de um commit, com o objetivo de identificar poss\u00edveis problemas no seu programa antes do envio do c\u00f3digo para o reposit\u00f3rio remoto. Os comandos listados acima s\u00e3o bons exemplos de execu\u00e7\u00f5es que podem ocorrer neste momento. Uma das ferramentas que prov\u00ea essa funcionalidade \u00e9 o pre-commit. Para saber mais, clique aqui . \ud83d\udc31 Configurando o GitHub Actions Crie a pasta .github/workflows dentro do seu reposit\u00f3rio. Essa \u00e9 a pasta padr\u00e3o para as configura\u00e7\u00f5es do GitHub Actions. mkdir -p .github/workflows Dentro da pasta crie um arquivo chamado main.yml . Esse arquivo ser\u00e1 utilizado para determinar quais passos ser\u00e3o executados na integra\u00e7\u00e3o. O arquivo deve possuir o seguinte conte\u00fado: name: main on: push: branches: - \"main\" tags: - \"*\" pull_request: branches: - \"main\" jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-python@v3 with: python-version: '3.10' cache: 'pip' - run: pip install -r dev-requirements.txt - name: Run isort run: python -m isort --check . - name: Run black run: python -m black --check . - name: Run flake8 run: python -m flake8 . --exclude=.venv - name: Run tests run: python -m pytest . Atrav\u00e9s do arquivo de configura\u00e7\u00e3o, n\u00f3s definimos que alguns passos ser\u00e3o executados toda vez que houver um push ou a abertura de um pull request no reposit\u00f3rio. Os passos executados ser\u00e3o os seguintes: 1 - Instalar todas as depend\u00eancias necess\u00e1rias. 2 - Executar o isort. 3 - Executar o black. 4 - Executar o flake8. 5 - Executar os testes. Como instalamos v\u00e1rias bibliotecas, precisamos atualizar nosso arquivo de requisitos. Como as bibliotecas que instalamos s\u00e3o para garantir a qualidade do c\u00f3digo e n\u00e3o s\u00e3o necess\u00e1rias na execu\u00e7\u00e3o da aplica\u00e7\u00e3o adicionaremos elas ao arquivo dev-requirements.txt . O arquivo ficar\u00e1 assim: -r requirements.txt pytest==7.1.2 httpie==3.2.1 isort==5.10.1 flake8==4.0.1 black==22.3.0 \ud83c\udf89 Pronto, a partir de agora, o GitHub Actions ir\u00e1 rodar todos as valida\u00e7\u00f5es e testes do seu projeto de forma automatizada e indicar\u00e1 se a constru\u00e7\u00e3o do mesmo est\u00e1 com problemas. \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: dev-requirements.txt modified: gerenciador_tarefas/gerenciador.py modified: tests/test_gerenciador.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .github/ pyproject.toml no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vemos uma pasta n\u00e3o rastreada, precisamos avisar ao controle de vers\u00e3o que monitore a pasta e seu conte\u00fado. git add .github/ Vamos adicionar tamb\u00e9m as novas depend\u00eancias instaladas e os arquivos que possivelmente foram modificados por nossas ferramentas de qualidade. git add dev-requirements tests gerenciador_tarefas pyproject.toml \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona integra\u00e7\u00e3o cont\u00ednua\" \ud83d\udc31 Por fim, envie ao GitHub a vers\u00e3o atualizada do projeto. git push \u2705 Pronto, agora o seu projeto est\u00e1 integrado com o GitHub Actions. \ud83c\udf89 Confira na aba actions do seu reposit\u00f3rio.","title":"\u2714\ufe0f Integra\u00e7\u00e3o cont\u00ednua"},{"location":"integracao/#integracao-continua","text":"","title":"\u2705 Integra\u00e7\u00e3o cont\u00ednua"},{"location":"integracao/#conceito","text":"O desenvolvedor integra o c\u00f3digo alterado e/ou desenvolvido ao projeto principal na mesma frequ\u00eancia com que as funcionalidades s\u00e3o desenvolvidas, sendo feito muitas vezes. Todo o nosso projeto ser\u00e1 constru\u00eddo utilizando testes automatizados, e sempre rodaremos os testes localmente. Mas como garantir que minha altera\u00e7\u00e3o n\u00e3o impacta com o restante do projeto, ter isto de forma simples e automatizada? Como garantir que a qualidade do c\u00f3digo foi mantida? Utilizaremos o servi\u00e7o GitHub Actions para checar que nosso c\u00f3digo n\u00e3o quebra a \"build\", ou seja, quando integrado o novo c\u00f3digo ao sistema, todo o sistema continua funcional. Basicamente, a grande vantagem da integra\u00e7\u00e3o cont\u00ednua est\u00e1 no feedback instant\u00e2neo. Isso funciona da seguinte forma: a cada commit no reposit\u00f3rio, o build \u00e9 feito automaticamente, com todos os testes sendo executados de forma autom\u00e1tica e falhas sendo detectadas. Se algum commit n\u00e3o compilar ou quebrar qualquer um dos testes, a equipe toma conhecimento instant\u00e2neamente (atrav\u00e9s de email, por exemplo, indicando as falhas e o commit causador das mesmas). A equipe pode ent\u00e3o corrigir o problema o mais r\u00e1pido poss\u00edvel, o que \u00e9 fundamental para n\u00e3o introduzir erros ao criar novas funcionalidades, refatorar, etc. Integra\u00e7\u00e3o cont\u00ednua \u00e9 mais uma forma de trazer seguran\u00e7a em rela\u00e7\u00e3o a mudan\u00e7as: voc\u00ea pode fazer modifica\u00e7\u00f5es sem medo, pois ser\u00e1 avisado caso algo saia do esperado.","title":"Conceito"},{"location":"integracao/#ferramentas","text":"Vamos instalar algumas ferramentas para nos ajudarem a terem um c\u00f3digo bem organizado e testado.","title":"Ferramentas"},{"location":"integracao/#isort","text":"","title":"\ud83d\udd20 isort"},{"location":"integracao/#o-que-e","text":"isort \u00e9 uma ferramenta que ordena de forma alfab\u00e9tica as importa\u00e7\u00f5es, separando as bilbiotecas que s\u00e3o padr\u00f5es da linguagem, as externas ao sistema e as nativas do pr\u00f3prio sistema.","title":"O que \u00e9?"},{"location":"integracao/#para-que-serve","text":"O isort ir\u00e1 modificar o seu c\u00f3digo ordenando as importa\u00e7\u00f5es alfab\u00e9ticamente. Dessa forma, o bloco de importa\u00e7\u00f5es fica organizado e padronizado no projeto.","title":"Para que serve?"},{"location":"integracao/#como-instalar","text":"Execute o comando abaixo: python -m pip install isort","title":"Como instalar"},{"location":"integracao/#configuracao","text":"Precisamos adicionar no arquivo pyproject.toml (voc\u00ea deve cria-lo) a seguinte configura\u00e7\u00e3o [tool.isort] profile = \"black\" line_length = 79 Assim evitamos um conflito com a ferramenta black e isort .","title":"Configura\u00e7\u00e3o"},{"location":"integracao/#como-executar","text":"python -m isort .","title":"Como executar"},{"location":"integracao/#black","text":"","title":"\u2728 Black"},{"location":"integracao/#o-que-e_1","text":"Black \u00e9 o formatador de c\u00f3digo Python intransigente. Ao us\u00e1-lo, voc\u00ea concorda em ceder o controle sobre as min\u00facias da formata\u00e7\u00e3o manual. Em troca, o black d\u00e1 a voc\u00ea velocidade, determinismo e liberdade do irritante pycodestyle sobre formata\u00e7\u00e3o. Voc\u00ea economizar\u00e1 tempo e energia mental para assuntos mais importantes.","title":"O que \u00e9?"},{"location":"integracao/#para-que-serve_1","text":"O black \u00e9 um formatador autom\u00e1tico de c\u00f3digo, ele ir\u00e1 modificar o seu c\u00f3digo seguindo o guia de estilo do Python. Iremos configur\u00e1-lo junto ao nosso editor para que a formata\u00e7\u00e3o seja feita atrav\u00e9s de um atalho do teclado como shift + ctrl + i.","title":"Para que serve?"},{"location":"integracao/#como-instalar_1","text":"Execute o comando abaixo: python -m pip install black","title":"Como instalar"},{"location":"integracao/#configuracao_1","text":"Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.black] line-length = 79","title":"Configura\u00e7\u00e3o"},{"location":"integracao/#como-executar_1","text":"python -m black . Assim evitamos um conflito com a ferramenta flake8 .","title":"Como executar"},{"location":"integracao/#flake8","text":"","title":"\ud83c\udfa8 Flake8"},{"location":"integracao/#o-que-e_2","text":"Flake8 \u00e9 um programa de linha de comando que verifica seu c\u00f3digo e busca por erros ou formata\u00e7\u00f5es que n\u00e3o seguem o guia de estilo padr\u00e3o do python, conhecido como PEP-8 . Al\u00e9m disso tamb\u00e9m verifica a complexidade ciclom\u00e1tica do seu c\u00f3digo.","title":"O que \u00e9?"},{"location":"integracao/#para-que-serve_2","text":"\u00c9 muito comum cometermos alguns erros de sintaxe, principalmente quando ainda estamos nos familiarizando com uma linguagem nova. Assim como durante o nosso dia a dia podemos esquecer algum c\u00f3digo n\u00e3o utilizado. Esta ferramenta vai analisar o seu c\u00f3digo e procurar poss\u00edveis erros, evitando assim que s\u00f3 ocorram no momento em que o c\u00f3digo for executado. Esta ferramenta tamb\u00e9m aponta poss\u00edveis linhas que n\u00e3o est\u00e3o seguindo o estilo de c\u00f3digo definido para a linguagem python. Outra coisa bem comum quando estamos escrevendo c\u00f3digo \u00e9 que uma parte dele come\u00e7a a se tornar t\u00e3o complexa que h\u00e1 n caminhos por onde seu algoritmo pode seguir. Normalmente isto indica que devemos modificar o c\u00f3digo para torn\u00e1-lo mais simples e leg\u00edvel. O Flake8 ir\u00e1 apontar qual parte do seu c\u00f3digo est\u00e1 complexa e que deve ser modificada. Esta ferramenta ser\u00e1 integrada ao editor, dessa maneira, ao salvar o arquivo, teremos os erros encontrados apontados diretamente no mesmo.","title":"Para que serve?"},{"location":"integracao/#como-instalar_2","text":"Execute o comando abaixo: python -m pip install flake8","title":"Como instalar"},{"location":"integracao/#como-executar_2","text":"python -m flake8 --exclude=.venv \u2139\ufe0f Pode ser necess\u00e1rio a interven\u00e7\u00f5es manuais para que o c\u00f3digo seja corrigido.","title":"Como executar"},{"location":"integracao/#pre-commit-mencao-honrosa","text":"Existem ferramentas que podem executar algum comando antes de um commit, com o objetivo de identificar poss\u00edveis problemas no seu programa antes do envio do c\u00f3digo para o reposit\u00f3rio remoto. Os comandos listados acima s\u00e3o bons exemplos de execu\u00e7\u00f5es que podem ocorrer neste momento. Uma das ferramentas que prov\u00ea essa funcionalidade \u00e9 o pre-commit. Para saber mais, clique aqui .","title":"\ud83d\udd75\ufe0fpre-commit (Men\u00e7\u00e3o honrosa \ud83c\udfc5)"},{"location":"integracao/#configurando-o-github-actions","text":"Crie a pasta .github/workflows dentro do seu reposit\u00f3rio. Essa \u00e9 a pasta padr\u00e3o para as configura\u00e7\u00f5es do GitHub Actions. mkdir -p .github/workflows Dentro da pasta crie um arquivo chamado main.yml . Esse arquivo ser\u00e1 utilizado para determinar quais passos ser\u00e3o executados na integra\u00e7\u00e3o. O arquivo deve possuir o seguinte conte\u00fado: name: main on: push: branches: - \"main\" tags: - \"*\" pull_request: branches: - \"main\" jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-python@v3 with: python-version: '3.10' cache: 'pip' - run: pip install -r dev-requirements.txt - name: Run isort run: python -m isort --check . - name: Run black run: python -m black --check . - name: Run flake8 run: python -m flake8 . --exclude=.venv - name: Run tests run: python -m pytest . Atrav\u00e9s do arquivo de configura\u00e7\u00e3o, n\u00f3s definimos que alguns passos ser\u00e3o executados toda vez que houver um push ou a abertura de um pull request no reposit\u00f3rio. Os passos executados ser\u00e3o os seguintes: 1 - Instalar todas as depend\u00eancias necess\u00e1rias. 2 - Executar o isort. 3 - Executar o black. 4 - Executar o flake8. 5 - Executar os testes. Como instalamos v\u00e1rias bibliotecas, precisamos atualizar nosso arquivo de requisitos. Como as bibliotecas que instalamos s\u00e3o para garantir a qualidade do c\u00f3digo e n\u00e3o s\u00e3o necess\u00e1rias na execu\u00e7\u00e3o da aplica\u00e7\u00e3o adicionaremos elas ao arquivo dev-requirements.txt . O arquivo ficar\u00e1 assim: -r requirements.txt pytest==7.1.2 httpie==3.2.1 isort==5.10.1 flake8==4.0.1 black==22.3.0 \ud83c\udf89 Pronto, a partir de agora, o GitHub Actions ir\u00e1 rodar todos as valida\u00e7\u00f5es e testes do seu projeto de forma automatizada e indicar\u00e1 se a constru\u00e7\u00e3o do mesmo est\u00e1 com problemas.","title":"\ud83d\udc31 Configurando o GitHub Actions"},{"location":"integracao/#salvando-a-versao-atual-do-codigo","text":"Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: dev-requirements.txt modified: gerenciador_tarefas/gerenciador.py modified: tests/test_gerenciador.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .github/ pyproject.toml no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vemos uma pasta n\u00e3o rastreada, precisamos avisar ao controle de vers\u00e3o que monitore a pasta e seu conte\u00fado. git add .github/ Vamos adicionar tamb\u00e9m as novas depend\u00eancias instaladas e os arquivos que possivelmente foram modificados por nossas ferramentas de qualidade. git add dev-requirements tests gerenciador_tarefas pyproject.toml \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona integra\u00e7\u00e3o cont\u00ednua\" \ud83d\udc31 Por fim, envie ao GitHub a vers\u00e3o atualizada do projeto. git push \u2705 Pronto, agora o seu projeto est\u00e1 integrado com o GitHub Actions. \ud83c\udf89 Confira na aba actions do seu reposit\u00f3rio.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"planejando/","text":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido \ud83d\udca1 Definindo o que iremos desenvolver Quando iniciamos um projeto, a primeira coisa que devemos conhecer s\u00e3o as \"regras de neg\u00f3cio\" do nosso projeto. Mas o que \u00e9 isso? \u00c9 a descri\u00e7\u00e3o de como o nosso sistema deve ser e como deve se comportar diante da intera\u00e7\u00e3o do usu\u00e1rio. Por exemplo, o sistema escolhido hoje \u00e9 para organizar uma lista de tarefas. \u270f\ufe0f Regras de neg\u00f3cio O sistema ser\u00e1 um gerenciador de tarefas e a primeira decis\u00e3o \u00e9 que nosso sistema deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis. Cada tarefa possui um identificador \u00fanico, um titulo, uma descri\u00e7\u00e3o e seu estado que pode ser finalizado/n\u00e3o-finalizado. O t\u00edtulo dever\u00e1 ter entre 3 e 50 caracteres e a descri\u00e7\u00e3o no m\u00e1ximo 140 caracteres. Como usu\u00e1rio devo ser capaz de: Adicionar e remover tarefas. Listar todas as tarefas e o crit\u00e9rio de ordena\u00e7\u00e3o \u00e9 seu estado. N\u00e3o finalizadas devem aparecer primeiro. Mudar o estado de n\u00e3o-finalizado para finalizado. Selecionar somente uma tarefa e exibi-la detalhadamente. O sistema deve apresentar testes. \ud83d\ude28 E agora, o que fazer? Por onde come\u00e7o? Vamos escolher nossas ferramentas!","title":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido"},{"location":"planejando/#planejando-o-que-sera-desenvolvido","text":"","title":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido"},{"location":"planejando/#definindo-o-que-iremos-desenvolver","text":"Quando iniciamos um projeto, a primeira coisa que devemos conhecer s\u00e3o as \"regras de neg\u00f3cio\" do nosso projeto. Mas o que \u00e9 isso? \u00c9 a descri\u00e7\u00e3o de como o nosso sistema deve ser e como deve se comportar diante da intera\u00e7\u00e3o do usu\u00e1rio. Por exemplo, o sistema escolhido hoje \u00e9 para organizar uma lista de tarefas.","title":"\ud83d\udca1 Definindo o que iremos desenvolver"},{"location":"planejando/#regras-de-negocio","text":"O sistema ser\u00e1 um gerenciador de tarefas e a primeira decis\u00e3o \u00e9 que nosso sistema deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis. Cada tarefa possui um identificador \u00fanico, um titulo, uma descri\u00e7\u00e3o e seu estado que pode ser finalizado/n\u00e3o-finalizado. O t\u00edtulo dever\u00e1 ter entre 3 e 50 caracteres e a descri\u00e7\u00e3o no m\u00e1ximo 140 caracteres. Como usu\u00e1rio devo ser capaz de: Adicionar e remover tarefas. Listar todas as tarefas e o crit\u00e9rio de ordena\u00e7\u00e3o \u00e9 seu estado. N\u00e3o finalizadas devem aparecer primeiro. Mudar o estado de n\u00e3o-finalizado para finalizado. Selecionar somente uma tarefa e exibi-la detalhadamente. O sistema deve apresentar testes. \ud83d\ude28 E agora, o que fazer? Por onde come\u00e7o? Vamos escolher nossas ferramentas!","title":"\u270f\ufe0f Regras de neg\u00f3cio"},{"location":"projeto/","text":"Iniciando o projeto J\u00e1 temos as esp\u00e1tulas, facas, colheres e outros instrumentos na mesa, mas para prosseguirmos, precisamos escolher os melhores ingredientes. Desenvolver um projeto n\u00e3o significa escrever tudo do zero e poderemos contar com ajuda de trechos escritos por outros programadores. estes trechos comuns de c\u00f3digo s\u00e3o chamados bibliotecas e vamos acabar adicionando algumas ao nosso projeto. Mas antes de tudo, precisamos iniciar nosso projeto. \u25b6\ufe0f Come\u00e7ando a tirar do papel o projeto Daremos nosso primeiro passo, criando um diret\u00f3rio onde ser\u00e3o armazenados todos os arquivos do projeto. Faremos isto utilizando o github, que \u00e9 uma plataforma gratuita, muita conhecida e que ir\u00e1 nos ajudar com algumas integra\u00e7\u00f5es no futuro. Mas por que iniciaremos criando o projeto l\u00e1 e n\u00e3o no pr\u00f3prio computador? O primeiro motivo \u00e9 que j\u00e1 criaremos o projeto com controle de vers\u00e3o, ou seja a cada passo da sua cria\u00e7\u00e3o vamos salvando as altera\u00e7\u00f5es, evitando que os passos se percam e caso necess\u00e1rio podemos desfazer algum passo errado. Outro motivo \u00e9 que se algo acontecer com seu computador, teremos salvo uma vers\u00e3o do projeto. Abra seu navegador, e acesse o seguinte endere\u00e7o http://github.com. Crie uma conta se ainda n\u00e3o tiver. Aperte o bot\u00e3o novo_reposit\u00f3rio. Preencha os campos como visto na imagem abaixo. Warning As setas indicam o que deve ser preenchido. Agora fa\u00e7a um \"clone\" do seu reposit\u00f3rio. Warning Os comandos abaixo devem ser modificados com seu email e nome de usu\u00e1rio do github. USUARIO deve ser modificado para seu usu\u00e1rio do github e EMAIL substituido pelo email utilizado no github. $ git clone https://github.com/USUARIO/gerenciador-tarefas.git Cloning into 'gerenciador-tarefas' ... remote: Counting objects: 5 , done . remote: Compressing objects: 100 % ( 4 /4 ) , done . remote: Total 5 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 0 Unpacking objects: 100 % ( 5 /5 ) , done . git clone \u00e9 um comando para criar uma c\u00f3pia dos arquivos e suas vers\u00f5es. Pode ser feito para trazer uma c\u00f3pia do reposit\u00f3rio do servidor para o computador local. Aproveite e j\u00e1 configure seu usu\u00e1rio git para este projeto, dentro do diret\u00f3rio rec\u00e9m clonado digite os seguintes comandos. $ git config --local user.email EMAIL $ git config --local user.name USUARIO \"Voil\u00e0\", j\u00e1 temos o projeto iniciado. Navegue at\u00e9 o diret\u00f3rio onde foi executado o comando de clone do projeto. Prossiga com a instala\u00e7\u00e3o das bibliotecas de acordo com o seu sistema operacional. Warning N\u00e3o se esque\u00e7a de entrar no diret\u00f3rio do projeto antes de continuar a instala\u00e7\u00e3o das bibliotecas. \ud83d\udda5\ufe0f O ambiente virtual Iniciei um projeto e ele utiliza a biblioteca fastapi na vers\u00e3o 0.2, tr\u00eas meses depois fui iniciar outro e a vers\u00e3o do fastapi j\u00e1 era 0.3. Ser\u00e1 que n\u00e3o d\u00e1 problema se eu mudar no primeiro projeto? Ou ser\u00e1 que mudo no segundo? Para evitar este tipo de problema, vamos criar o que chamaremos de ambiente virtual. Na pr\u00e1tica o que vamos fazer \u00e9 instalar as bibliotecas em um diret\u00f3rio que est\u00e1 relacionado ao projeto. Assim cada projeto pode ter suas pr\u00f3prias bibliotecas na vers\u00e3o que quiser. O comando para isto \u00e9 python3 -m venv .venv , ou python -m venv .venv no windows, sendo que .venv \u00e9 o nome deste ambiente isolado. Este ambiente isolado ser\u00e1 visto como um diret\u00f3rio criado na pasta do projeto. O ponto na frente do nome faz com que o diret\u00f3rio fique oculto. Depois de criado, temos de ativar este ambiente e isto \u00e9 importante pois sempre que decidir trabalhar neste projeto voc\u00ea dever\u00e1 repetir este passo. Digite o comando: source .venv/bin/activate em linux ou .venv\\Scripts\\activate.bat no windows. Pronto, agora estamos preparados para instalar as bibliotecas que precisaremos. \ud83d\udcda Bibliotecas e utilit\u00e1rios Chegou a hora de instalar algumas bibliotecas e utilit\u00e1rios que nos auxiliar\u00e3o na cria\u00e7\u00e3o do nosso sistema web, na realiza\u00e7\u00e3o de testes unit\u00e1rios e testes manuais. Siga os passos de acordo com o seu sistema operacional para cada ferramenta. Tenha sempre certeza de que a ferramenta est\u00e1 instalada e funcionando. Warning Certifique-se de que seu ambiente est\u00e1 ativo antes de prosseguir com as instala\u00e7\u00f5es. \u26a1 FastAPI O que \u00e9? O fastapi \u00e9 uma ferramenta para desenvolvimento web, possui alta performance, f\u00e1cil de aprender, r\u00e1pida para escrever c\u00f3digo e pronta para colocar o c\u00f3digo no ar. Para que serve? Serve para escrevermos nossa aplica\u00e7\u00e3o web de forma r\u00e1pida e customiz\u00e1vel. Possui fun\u00e7\u00f5es que auxiliam opera\u00e7\u00f5es como roteamento, tratamento de requisi\u00e7\u00f5es, renderiza\u00e7\u00e3o de conte\u00fado, gerenciamento de sess\u00e3o e cookies, assim como v\u00e1rias outras que s\u00e3o t\u00edpicas da web. Como instalar Warning Preste aten\u00e7\u00e3o que os comandos ser\u00e3o executados dentro do diret\u00f3rio do projeto. \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install fastapi . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install fastapi . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -c \"import fastapi\" . nenhum erro deve ocorrer. Abra um terminal e digite python -c \"import fastapi\" . nenhum erro deve ocorrer. \ud83d\udd17 Httpie O que \u00e9? HTTPie \u00e9 um cliente HTTP por linha de comando. Seu objetivo \u00e9 transformar a intera\u00e7\u00e3o com servi\u00e7os web o mais humano poss\u00edvel. Para que serve? Diversos momentos do curso, teremos de testar manualmente se nosso sistema est\u00e1 funcionando, ainda que possua testes automatizados. Esta ferramenta ajuda a fazer estes testes de uma maneira mais simples. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install httpie . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install httpie . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite http --version . Abra um terminal e digite http --version . Warning Note que foi utilizado o comando http ao inv\u00e9s de httpie, este \u00e9 o nome do execut\u00e1vel do httpie depois de instalado no sistema. A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: $ http --version 3 .2.1 \ud83e\udd84 Uvicorn O que \u00e9? O uvicorn \u00e9 um servidor de aplica\u00e7\u00e3o com suporte a frameworks ass\u00edncronos. Para que serve? O uvicorn serve para rodar a nossa aplica\u00e7\u00e3o, tanto na nossa m\u00e1quina quanto em um servidor na internet. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto, ative o ambiente virtual e agora digite pip install uvicorn . Abra um terminal, navegue at\u00e9 a pasta do projeto, ative o ambiente virtual e por fim digite pip install uvicorn . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Wnndows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Ative o ambiente virtual, Agora digite uvicorn --help . Abra um terminal e digite uvicorn --help . A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: Usage: uvicorn [ OPTIONS ] APP Options: --host TEXT Bind socket to this host. [ default: 127 .0.0.1 ] --port INTEGER Bind socket to this port. [ default: 8000 ] --uds TEXT Bind to a UNIX domain socket. --fd INTEGER Bind to socket from this file descriptor. --reload Enable auto-reload. --reload-dir TEXT Set reload directories explicitly, instead of using the current working directory. --workers INTEGER Number of worker processes. Defaults to the $WEB_CONCURRENCY environment variable if available. Not valid with --reload. --loop [ auto | asyncio | uvloop | iocp ] Event loop implementation. [ default: auto ] --http [ auto | h11 | httptools ] HTTP protocol implementation. [ default: auto ] --ws [ auto | none | websockets | wsproto ] WebSocket protocol implementation. [ default: auto ] --lifespan [ auto | on | off ] Lifespan implementation. [ default: auto ] --interface [ auto | asgi3 | asgi2 | wsgi ] Select ASGI3, ASGI2, or WSGI as the application interface. [ default: auto ] --env-file PATH Environment configuration file. --log-config PATH Logging configuration file. --log-level [ critical | error | warning | info | debug | trace ] Log level. [ default: info ] --access-log / --no-access-log Enable/Disable access log. --proxy-headers / --no-proxy-headers Enable/Disable X-Forwarded-Proto, X-Forwarded-For, X-Forwarded-Port to populate remote address info. --forwarded-allow-ips TEXT Comma seperated list of IPs to trust with proxy headers. Defaults to the $FORWARDED_ALLOW_IPS environment variable if available, or '127.0.0.1' . --root-path TEXT Set the ASGI 'root_path' for applications submounted below a given URL path. --limit-concurrency INTEGER Maximum number of concurrent connections or tasks to allow, before issuing HTTP 503 responses. --limit-max-requests INTEGER Maximum number of requests to service before terminating the process. --timeout-keep-alive INTEGER Close Keep-Alive connections if no new data is received within this timeout. [ default: 5 ] --ssl-keyfile TEXT SSL key file --ssl-certfile TEXT SSL certificate file --ssl-version INTEGER SSL version to use ( see stdlib ssl module 's) [default: 2] --ssl-cert-reqs INTEGER Whether client certificate is required (see stdlib ssl module' s ) [ default: 0 ] --ssl-ca-certs TEXT CA certificates file --ssl-ciphers TEXT Ciphers to use ( see stdlib ssl module ' s ) [ default: TLSv1 ] --header TEXT Specify custom default HTTP response headers as a Name:Value pair --help Show this message and exit. \ud83d\udea6 Pytest O que \u00e9? O framework pytest \u00e9 f\u00e1cil para escrever teste simples, ainda escala para suportar testes funcionais complexos para aplica\u00e7\u00f5es e bibliotecas. Para que serve? J\u00e1 dizia Michael C. Feathers, \"Um c\u00f3digo sem testes, \u00e9 um c\u00f3digo ruim. N\u00e3o importa qu\u00e3o bem ele foi escrito\". Vamos ent\u00e3o instalar o pytest, que \u00e9 uma ferramenta que auxilia na execu\u00e7\u00e3o de testes. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install pytest . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install pytest . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite pytest --version . Abra um terminal e digite pytest --version . A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: $ pytest --version pytest 7 .1.2 \u26a0\ufe0f Nota importante sobre ambientes virtuais Se neste momento, voc\u00ea digitar cmd no windows, ou abrir um terminal no linux e digitar python3 ou python no windows, e em seguida tentar importar a bilbioteca fastapi o seguinte erro ser\u00e1 mostrado. \ud83d\ude31 $ python Python 3 .10.4 ( main, Apr 20 2022 , 22 :30:21 ) [ GCC 11 .2.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> import fastapi Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> ModuleNotFoundError: No module named 'fastapi' >>> Tip Utilize Ctrl + d ou exit() para sair do python. Acontece que instalamos o FastAPI somente no ambiente virtual. Para entrarmos no ambiente virtual digite source <venv>/bin/activate ou <venv>\\Scripts\\activate.bat . N\u00e3o esque\u00e7a de trocar o <venv> pelo nome do ambiente virtual criado. Por exemplo, se voc\u00ea seguiu esse tutorial, provavelmente voc\u00ea usou o nome .venv , ent\u00e3o o comando ser\u00e1 source .venv/bin/activate ou .venv\\Scripts\\activate.bat . Salvando o momento atual do nosso projeto Neste momento seu diret\u00f3rio deve estar assim: . \u251c\u2500\u2500 LICENSE \u2514\u2500\u2500 README.md E se eu te pedisse agora uma c\u00f3pia do projeto, como eu saberia de toda essa lista de coisas necess\u00e1rias pro c\u00f3digo rodar? Para evitar este problema criaremos arquivos com as depend\u00eancias que instalamos no nosso projeto. Vamos come\u00e7ar criando um arquivo chamado requirements.txt com o seguinte conte\u00fado. fastapi==0.77.1 uvicorn==0.17.6 Depois criaremos um segundo arquivo chamado dev-requirements.txt e colocaremos o seguinte conte\u00fado. -r requirements.txt pytest==7.1.2 httpie==3.2.1 Warning Os arquivos devem ser criados na pasta principal do projeto. Teremos ent\u00e3o os seguintes arquivos no nosso diret\u00f3rio. . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 dev-requirements.txt \u2514\u2500\u2500 requirements.txt Por que arquivos separados? No requirements.txt , s\u00f3 colocamos aquelas bibliotecas realmente necess\u00e1rias para o sistema ir ao ar, j\u00e1 no dev-requirements.txt , temos as dep\u00eandencias que somente s\u00e3o \u00fateis enquanto estamos desenvolvendo o sistema. Aquele -r requirements.txt no arquivo de desenvolvimento garante que as depend\u00eancias principais ser\u00e3o instaladas e em seguidas as outras que somente s\u00e3o \u00fateis durante o desenvolvimento. Quando formos colocar o site no ar, estes arquivos ser\u00e3o bem \u00fateis. Instalado as depend\u00eancias, vamos salvar uma primeira vers\u00e3o do nosso projeto com o nosso andamento? Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) dev-requirements.txt requirements.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois arquivos n\u00e3o rastreados, precisamos avisar ao controle de vers\u00e3o que monitore estes arquivos. $ git add requirements.txt dev-requirements.txt \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona depend\u00eancias do projeto\" \ud83d\udd27 Por fim, envie ao GitHub a vers\u00e3o atualizada do projeto. git push \ud83c\udf70 Entusiasmados a come\u00e7ar a escrever sua aplica\u00e7\u00e3o? Agora que temos todo o ambiente configurado, j\u00e1 estamos bem pr\u00f3ximo disso, faremos um nivelamento de conhecimento sobre web e python e em breve termos nossa aplica\u00e7\u00e3o no ar!","title":"\ud83d\udcd6 Iniciando o projeto"},{"location":"projeto/#iniciando-o-projeto","text":"J\u00e1 temos as esp\u00e1tulas, facas, colheres e outros instrumentos na mesa, mas para prosseguirmos, precisamos escolher os melhores ingredientes. Desenvolver um projeto n\u00e3o significa escrever tudo do zero e poderemos contar com ajuda de trechos escritos por outros programadores. estes trechos comuns de c\u00f3digo s\u00e3o chamados bibliotecas e vamos acabar adicionando algumas ao nosso projeto. Mas antes de tudo, precisamos iniciar nosso projeto.","title":"Iniciando o projeto"},{"location":"projeto/#comecando-a-tirar-do-papel-o-projeto","text":"Daremos nosso primeiro passo, criando um diret\u00f3rio onde ser\u00e3o armazenados todos os arquivos do projeto. Faremos isto utilizando o github, que \u00e9 uma plataforma gratuita, muita conhecida e que ir\u00e1 nos ajudar com algumas integra\u00e7\u00f5es no futuro. Mas por que iniciaremos criando o projeto l\u00e1 e n\u00e3o no pr\u00f3prio computador? O primeiro motivo \u00e9 que j\u00e1 criaremos o projeto com controle de vers\u00e3o, ou seja a cada passo da sua cria\u00e7\u00e3o vamos salvando as altera\u00e7\u00f5es, evitando que os passos se percam e caso necess\u00e1rio podemos desfazer algum passo errado. Outro motivo \u00e9 que se algo acontecer com seu computador, teremos salvo uma vers\u00e3o do projeto. Abra seu navegador, e acesse o seguinte endere\u00e7o http://github.com. Crie uma conta se ainda n\u00e3o tiver. Aperte o bot\u00e3o novo_reposit\u00f3rio. Preencha os campos como visto na imagem abaixo. Warning As setas indicam o que deve ser preenchido. Agora fa\u00e7a um \"clone\" do seu reposit\u00f3rio. Warning Os comandos abaixo devem ser modificados com seu email e nome de usu\u00e1rio do github. USUARIO deve ser modificado para seu usu\u00e1rio do github e EMAIL substituido pelo email utilizado no github. $ git clone https://github.com/USUARIO/gerenciador-tarefas.git Cloning into 'gerenciador-tarefas' ... remote: Counting objects: 5 , done . remote: Compressing objects: 100 % ( 4 /4 ) , done . remote: Total 5 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 0 Unpacking objects: 100 % ( 5 /5 ) , done . git clone \u00e9 um comando para criar uma c\u00f3pia dos arquivos e suas vers\u00f5es. Pode ser feito para trazer uma c\u00f3pia do reposit\u00f3rio do servidor para o computador local. Aproveite e j\u00e1 configure seu usu\u00e1rio git para este projeto, dentro do diret\u00f3rio rec\u00e9m clonado digite os seguintes comandos. $ git config --local user.email EMAIL $ git config --local user.name USUARIO \"Voil\u00e0\", j\u00e1 temos o projeto iniciado. Navegue at\u00e9 o diret\u00f3rio onde foi executado o comando de clone do projeto. Prossiga com a instala\u00e7\u00e3o das bibliotecas de acordo com o seu sistema operacional. Warning N\u00e3o se esque\u00e7a de entrar no diret\u00f3rio do projeto antes de continuar a instala\u00e7\u00e3o das bibliotecas.","title":"\u25b6\ufe0f Come\u00e7ando a tirar do papel o projeto"},{"location":"projeto/#o-ambiente-virtual","text":"Iniciei um projeto e ele utiliza a biblioteca fastapi na vers\u00e3o 0.2, tr\u00eas meses depois fui iniciar outro e a vers\u00e3o do fastapi j\u00e1 era 0.3. Ser\u00e1 que n\u00e3o d\u00e1 problema se eu mudar no primeiro projeto? Ou ser\u00e1 que mudo no segundo? Para evitar este tipo de problema, vamos criar o que chamaremos de ambiente virtual. Na pr\u00e1tica o que vamos fazer \u00e9 instalar as bibliotecas em um diret\u00f3rio que est\u00e1 relacionado ao projeto. Assim cada projeto pode ter suas pr\u00f3prias bibliotecas na vers\u00e3o que quiser. O comando para isto \u00e9 python3 -m venv .venv , ou python -m venv .venv no windows, sendo que .venv \u00e9 o nome deste ambiente isolado. Este ambiente isolado ser\u00e1 visto como um diret\u00f3rio criado na pasta do projeto. O ponto na frente do nome faz com que o diret\u00f3rio fique oculto. Depois de criado, temos de ativar este ambiente e isto \u00e9 importante pois sempre que decidir trabalhar neste projeto voc\u00ea dever\u00e1 repetir este passo. Digite o comando: source .venv/bin/activate em linux ou .venv\\Scripts\\activate.bat no windows. Pronto, agora estamos preparados para instalar as bibliotecas que precisaremos.","title":"\ud83d\udda5\ufe0f O ambiente virtual"},{"location":"projeto/#bibliotecas-e-utilitarios","text":"Chegou a hora de instalar algumas bibliotecas e utilit\u00e1rios que nos auxiliar\u00e3o na cria\u00e7\u00e3o do nosso sistema web, na realiza\u00e7\u00e3o de testes unit\u00e1rios e testes manuais. Siga os passos de acordo com o seu sistema operacional para cada ferramenta. Tenha sempre certeza de que a ferramenta est\u00e1 instalada e funcionando. Warning Certifique-se de que seu ambiente est\u00e1 ativo antes de prosseguir com as instala\u00e7\u00f5es.","title":"\ud83d\udcda Bibliotecas e utilit\u00e1rios"},{"location":"projeto/#fastapi","text":"O que \u00e9? O fastapi \u00e9 uma ferramenta para desenvolvimento web, possui alta performance, f\u00e1cil de aprender, r\u00e1pida para escrever c\u00f3digo e pronta para colocar o c\u00f3digo no ar. Para que serve? Serve para escrevermos nossa aplica\u00e7\u00e3o web de forma r\u00e1pida e customiz\u00e1vel. Possui fun\u00e7\u00f5es que auxiliam opera\u00e7\u00f5es como roteamento, tratamento de requisi\u00e7\u00f5es, renderiza\u00e7\u00e3o de conte\u00fado, gerenciamento de sess\u00e3o e cookies, assim como v\u00e1rias outras que s\u00e3o t\u00edpicas da web. Como instalar Warning Preste aten\u00e7\u00e3o que os comandos ser\u00e3o executados dentro do diret\u00f3rio do projeto. \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install fastapi . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install fastapi . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite python -c \"import fastapi\" . nenhum erro deve ocorrer. Abra um terminal e digite python -c \"import fastapi\" . nenhum erro deve ocorrer.","title":"\u26a1 FastAPI"},{"location":"projeto/#httpie","text":"O que \u00e9? HTTPie \u00e9 um cliente HTTP por linha de comando. Seu objetivo \u00e9 transformar a intera\u00e7\u00e3o com servi\u00e7os web o mais humano poss\u00edvel. Para que serve? Diversos momentos do curso, teremos de testar manualmente se nosso sistema est\u00e1 funcionando, ainda que possua testes automatizados. Esta ferramenta ajuda a fazer estes testes de uma maneira mais simples. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install httpie . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install httpie . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite http --version . Abra um terminal e digite http --version . Warning Note que foi utilizado o comando http ao inv\u00e9s de httpie, este \u00e9 o nome do execut\u00e1vel do httpie depois de instalado no sistema. A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: $ http --version 3 .2.1","title":"\ud83d\udd17 Httpie"},{"location":"projeto/#uvicorn","text":"O que \u00e9? O uvicorn \u00e9 um servidor de aplica\u00e7\u00e3o com suporte a frameworks ass\u00edncronos. Para que serve? O uvicorn serve para rodar a nossa aplica\u00e7\u00e3o, tanto na nossa m\u00e1quina quanto em um servidor na internet. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto, ative o ambiente virtual e agora digite pip install uvicorn . Abra um terminal, navegue at\u00e9 a pasta do projeto, ative o ambiente virtual e por fim digite pip install uvicorn . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Wnndows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Ative o ambiente virtual, Agora digite uvicorn --help . Abra um terminal e digite uvicorn --help . A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: Usage: uvicorn [ OPTIONS ] APP Options: --host TEXT Bind socket to this host. [ default: 127 .0.0.1 ] --port INTEGER Bind socket to this port. [ default: 8000 ] --uds TEXT Bind to a UNIX domain socket. --fd INTEGER Bind to socket from this file descriptor. --reload Enable auto-reload. --reload-dir TEXT Set reload directories explicitly, instead of using the current working directory. --workers INTEGER Number of worker processes. Defaults to the $WEB_CONCURRENCY environment variable if available. Not valid with --reload. --loop [ auto | asyncio | uvloop | iocp ] Event loop implementation. [ default: auto ] --http [ auto | h11 | httptools ] HTTP protocol implementation. [ default: auto ] --ws [ auto | none | websockets | wsproto ] WebSocket protocol implementation. [ default: auto ] --lifespan [ auto | on | off ] Lifespan implementation. [ default: auto ] --interface [ auto | asgi3 | asgi2 | wsgi ] Select ASGI3, ASGI2, or WSGI as the application interface. [ default: auto ] --env-file PATH Environment configuration file. --log-config PATH Logging configuration file. --log-level [ critical | error | warning | info | debug | trace ] Log level. [ default: info ] --access-log / --no-access-log Enable/Disable access log. --proxy-headers / --no-proxy-headers Enable/Disable X-Forwarded-Proto, X-Forwarded-For, X-Forwarded-Port to populate remote address info. --forwarded-allow-ips TEXT Comma seperated list of IPs to trust with proxy headers. Defaults to the $FORWARDED_ALLOW_IPS environment variable if available, or '127.0.0.1' . --root-path TEXT Set the ASGI 'root_path' for applications submounted below a given URL path. --limit-concurrency INTEGER Maximum number of concurrent connections or tasks to allow, before issuing HTTP 503 responses. --limit-max-requests INTEGER Maximum number of requests to service before terminating the process. --timeout-keep-alive INTEGER Close Keep-Alive connections if no new data is received within this timeout. [ default: 5 ] --ssl-keyfile TEXT SSL key file --ssl-certfile TEXT SSL certificate file --ssl-version INTEGER SSL version to use ( see stdlib ssl module 's) [default: 2] --ssl-cert-reqs INTEGER Whether client certificate is required (see stdlib ssl module' s ) [ default: 0 ] --ssl-ca-certs TEXT CA certificates file --ssl-ciphers TEXT Ciphers to use ( see stdlib ssl module ' s ) [ default: TLSv1 ] --header TEXT Specify custom default HTTP response headers as a Name:Value pair --help Show this message and exit.","title":"\ud83e\udd84 Uvicorn"},{"location":"projeto/#pytest","text":"O que \u00e9? O framework pytest \u00e9 f\u00e1cil para escrever teste simples, ainda escala para suportar testes funcionais complexos para aplica\u00e7\u00f5es e bibliotecas. Para que serve? J\u00e1 dizia Michael C. Feathers, \"Um c\u00f3digo sem testes, \u00e9 um c\u00f3digo ruim. N\u00e3o importa qu\u00e3o bem ele foi escrito\". Vamos ent\u00e3o instalar o pytest, que \u00e9 uma ferramenta que auxilia na execu\u00e7\u00e3o de testes. Como instalar \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Navegue ate o nosso projeto e agora digite pip install pytest . Abra um terminal, navegue at\u00e9 a pasta do projeto e por fim digite pip install pytest . Vamos verificar se deu tudo certo? \ud83d\udda5\ufe0f Windows \ud83d\udc27\ud83c\udf4e Ubuntu/Mac Clique no bot\u00e3o iniciar, digite cmd e abra o programa prompt de comandos . Agora digite pytest --version . Abra um terminal e digite pytest --version . A sa\u00edda para ambos os sistemas operacionais dever\u00e1 ser similar a apresentada abaixo: $ pytest --version pytest 7 .1.2","title":"\ud83d\udea6 Pytest"},{"location":"projeto/#nota-importante-sobre-ambientes-virtuais","text":"Se neste momento, voc\u00ea digitar cmd no windows, ou abrir um terminal no linux e digitar python3 ou python no windows, e em seguida tentar importar a bilbioteca fastapi o seguinte erro ser\u00e1 mostrado. \ud83d\ude31 $ python Python 3 .10.4 ( main, Apr 20 2022 , 22 :30:21 ) [ GCC 11 .2.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> import fastapi Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> ModuleNotFoundError: No module named 'fastapi' >>> Tip Utilize Ctrl + d ou exit() para sair do python. Acontece que instalamos o FastAPI somente no ambiente virtual. Para entrarmos no ambiente virtual digite source <venv>/bin/activate ou <venv>\\Scripts\\activate.bat . N\u00e3o esque\u00e7a de trocar o <venv> pelo nome do ambiente virtual criado. Por exemplo, se voc\u00ea seguiu esse tutorial, provavelmente voc\u00ea usou o nome .venv , ent\u00e3o o comando ser\u00e1 source .venv/bin/activate ou .venv\\Scripts\\activate.bat .","title":"\u26a0\ufe0f Nota importante sobre ambientes virtuais"},{"location":"projeto/#salvando-o-momento-atual-do-nosso-projeto","text":"Neste momento seu diret\u00f3rio deve estar assim: . \u251c\u2500\u2500 LICENSE \u2514\u2500\u2500 README.md E se eu te pedisse agora uma c\u00f3pia do projeto, como eu saberia de toda essa lista de coisas necess\u00e1rias pro c\u00f3digo rodar? Para evitar este problema criaremos arquivos com as depend\u00eancias que instalamos no nosso projeto. Vamos come\u00e7ar criando um arquivo chamado requirements.txt com o seguinte conte\u00fado. fastapi==0.77.1 uvicorn==0.17.6 Depois criaremos um segundo arquivo chamado dev-requirements.txt e colocaremos o seguinte conte\u00fado. -r requirements.txt pytest==7.1.2 httpie==3.2.1 Warning Os arquivos devem ser criados na pasta principal do projeto. Teremos ent\u00e3o os seguintes arquivos no nosso diret\u00f3rio. . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 dev-requirements.txt \u2514\u2500\u2500 requirements.txt Por que arquivos separados? No requirements.txt , s\u00f3 colocamos aquelas bibliotecas realmente necess\u00e1rias para o sistema ir ao ar, j\u00e1 no dev-requirements.txt , temos as dep\u00eandencias que somente s\u00e3o \u00fateis enquanto estamos desenvolvendo o sistema. Aquele -r requirements.txt no arquivo de desenvolvimento garante que as depend\u00eancias principais ser\u00e3o instaladas e em seguidas as outras que somente s\u00e3o \u00fateis durante o desenvolvimento. Quando formos colocar o site no ar, estes arquivos ser\u00e3o bem \u00fateis. Instalado as depend\u00eancias, vamos salvar uma primeira vers\u00e3o do nosso projeto com o nosso andamento? Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) dev-requirements.txt requirements.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois arquivos n\u00e3o rastreados, precisamos avisar ao controle de vers\u00e3o que monitore estes arquivos. $ git add requirements.txt dev-requirements.txt \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adiciona depend\u00eancias do projeto\" \ud83d\udd27 Por fim, envie ao GitHub a vers\u00e3o atualizada do projeto. git push \ud83c\udf70 Entusiasmados a come\u00e7ar a escrever sua aplica\u00e7\u00e3o? Agora que temos todo o ambiente configurado, j\u00e1 estamos bem pr\u00f3ximo disso, faremos um nivelamento de conhecimento sobre web e python e em breve termos nossa aplica\u00e7\u00e3o no ar!","title":"Salvando o momento atual do nosso projeto"},{"location":"python/","text":"\ud83d\udc0d Primeiros passos com python Infelizmente esse tutorial foi pensado para ser ministrado em apenas algumas horas, o que nos deixa com pouco tempo para aprofundar na linguagem, aqui ser\u00e3o apresentados apenas alguns conceitos que ser\u00e3o necess\u00e1rios para o restante do tutorial. Caso tenha chegado aqui por outros meios que n\u00e3o o curso presencial, e n\u00e3o tenha conhecimento na linguagem, recomendo dar uma parada, e assistir as excelentes aulas do Professor Masanori. O python para zumbis tem sido uma excelente porta para muitas pessoas. Uma outra dica \u00e9 a Live de Python que ocorre \u00e0s segundas, sempre \u00e0s 22h. Abra um console(sim, a tela preta), digite python e aproveite para testar os comandos ensinados abaixo de uma forma interativa. Ol\u00e1 mundo Ol\u00e1 Mundo em python \u00e9 t\u00e3o simples como print('Ol\u00e1 mundo') por isso um Ol\u00e1 mundo mais pyth\u00f4nico seria import antigravity . Python \u00e9 conhecido por suas baterias inclu\u00eddas, e at\u00e9 mesmo o Ol\u00e1 mundo pode ser importado import __hello__ . Por Favor e Obrigado Duas fun\u00e7\u00f5es que podem ser bastante \u00fateis durante o desenvolvimento python e que costumo dizer que s\u00e3o como \"por favor\" e \"obrigado\", s\u00e3o as fun\u00e7\u00f5es help e dir. A fun\u00e7\u00e3o \"help\" pede ajuda sobre um determinado recurso, funcionando inclusive com palavras reservadas como 'if'. \u00c9 retornado a documenta\u00e7\u00e3o daquele recurso. >>> help ( abs ) Help on built - in function abs in module builtins : abs ( x , / ) Return the absolute value of the argument . >>> help ( 'if' ) The \"if\" statement ****************** The \"if\" statement is used for conditional execution : if_stmt : := \"if\" expression \":\" suite ( \"elif\" expression \":\" suite ) * [ \"else\" \":\" suite ] ... A fun\u00e7\u00e3o \"dir\" lista todos os atributos e m\u00e9todos de uma determinada inst\u00e2ncia. Como em python tudo \u00e9 objeto, esta fun\u00e7\u00e3o mostra como a inst\u00e2ncia do objeto se comporta e quais s\u00e3o seus atributos. >>> dir ( 5 ) [ '__abs__' , '__add__' , '__and__' , '__bool__' , '__ceil__' , '__class__' , '__delattr__' , '__dir__' , '__divmod__' , '__doc__' , '__eq__' , '__float__' , '__floor__' , '__floordiv__' , '__format__' , '__ge__' , '__getattribute__' , '__getnewargs__' , '__gt__' , '__hash__' , '__index__' , '__init__' , '__init_subclass__' , '__int__' , '__invert__' , '__le__' , '__lshift__' , '__lt__' , '__mod__' , '__mul__' , '__ne__' , '__neg__' , '__new__' , '__or__' , '__pos__' , '__pow__' , '__radd__' , '__rand__' , '__rdivmod__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__rfloordiv__' , '__rlshift__' , '__rmod__' , '__rmul__' , '__ror__' , '__round__' , '__rpow__' , '__rrshift__' , '__rshift__' , '__rsub__' , '__rtruediv__' , '__rxor__' , '__setattr__' , '__sizeof__' , '__str__' , '__sub__' , '__subclasshook__' , '__truediv__' , '__trunc__' , '__xor__' , 'bit_length' , 'conjugate' , 'denominator' , 'from_bytes' , 'imag' , 'numerator' , 'real' , 'to_bytes' ] Estrutura de chave e valor Python possui por padr\u00e3o uma estrutura de dados de array associativo, que \u00e9 chamado dicion\u00e1rio. Esta estrutura armazena valores associando uma chave a seu conte\u00fado. Veja abaixo algumas tarefas rudimentares com esta estrutura. >>> tarefas = {} # inicializando uma estrutura vazia >>> tarefas [ 1 ] = 'tarefa 1' # definindo uma tarefa de chave 1, com conte\u00fado 'tarefa 1' >>> print ( tarefas [ 1 ]) # exibindo a tarefa 1 >>> tarefas [ 2 ] = 'tarefa 2' # definindo uma tarefa de chave 2, com conte\u00fado 'tarefa 2' >>> tarefas [ 3 ] = 'tarefa-3' # definindo uma tarefa de chave 3, com conte\u00fado 'tarefa 3' >>> tarefas [ 3 ] = 'tarefa 3' # editando uma tarefa >>> del tarefas [ 1 ] # removendo a tarefa Percorrendo estruturas O la\u00e7o de repeti\u00e7\u00e3o da linguagem Python \u00e9 atrav\u00e9s de itera\u00e7\u00e3o de cole\u00e7\u00f5es. Tudo que pode ser percorr\u00edvel pode ser utilizado em uma estrutura de repeti\u00e7\u00e3o. >>> for tarefa in tarefas : print ( tarefa ) Fun\u00e7\u00f5es Por\u00e7\u00e3o de c\u00f3digo que resolve um problema muito espec\u00edfico. Boas pr\u00e1ticas dizem que uma fun\u00e7\u00e3o deve fazer somente uma coisa e fazer isto bem. def soma ( x , y ): return x + y Decorador \u00c9 um a\u00e7\u00facar sint\u00e1tico que nos permite alterar mais convenientemente fun\u00e7\u00f5es e m\u00e9todos. Pode ser definido como uma fun\u00e7\u00e3o, que ao inv\u00e9s de retornar algum resultado, retorna a fun\u00e7\u00e3o recebida como par\u00e2metro modificada. def p_decorate ( func ): def func_wrapper ( name ): return \"<p> {} </p>\" . format ( func ( name )) return func_wrapper @p_decorate def get_text ( name ): return \"lorem ipsum, {} dolor sit amet\" . format ( name ) print ( get_text ( \"John\" )) Sa\u00edda: <p>lorem ipsum, John dolor sit amet</p> Vimos um pouco sobre a web, demos uma passada no python, ent\u00e3o agora j\u00e1 vamos come\u00e7ar a escrever c\u00f3digo? Calma, ainda temos mais um conceito que \u00e9 muito importante para n\u00f3s. J\u00e1 ouviu falar do desenvolvimento guiado por testes, que popularmente \u00e9 conhecido pelas letras TDD ? Vamos aprender como e por que escrever testes automatizados antes mesmo de escrever c\u00f3digo.","title":"\ud83d\udc0d Primeiros passos com python"},{"location":"python/#primeiros-passos-com-python","text":"Infelizmente esse tutorial foi pensado para ser ministrado em apenas algumas horas, o que nos deixa com pouco tempo para aprofundar na linguagem, aqui ser\u00e3o apresentados apenas alguns conceitos que ser\u00e3o necess\u00e1rios para o restante do tutorial. Caso tenha chegado aqui por outros meios que n\u00e3o o curso presencial, e n\u00e3o tenha conhecimento na linguagem, recomendo dar uma parada, e assistir as excelentes aulas do Professor Masanori. O python para zumbis tem sido uma excelente porta para muitas pessoas. Uma outra dica \u00e9 a Live de Python que ocorre \u00e0s segundas, sempre \u00e0s 22h. Abra um console(sim, a tela preta), digite python e aproveite para testar os comandos ensinados abaixo de uma forma interativa.","title":"\ud83d\udc0d Primeiros passos com python"},{"location":"python/#ola-mundo","text":"Ol\u00e1 Mundo em python \u00e9 t\u00e3o simples como print('Ol\u00e1 mundo') por isso um Ol\u00e1 mundo mais pyth\u00f4nico seria import antigravity . Python \u00e9 conhecido por suas baterias inclu\u00eddas, e at\u00e9 mesmo o Ol\u00e1 mundo pode ser importado import __hello__ .","title":"Ol\u00e1 mundo"},{"location":"python/#por-favor-e-obrigado","text":"Duas fun\u00e7\u00f5es que podem ser bastante \u00fateis durante o desenvolvimento python e que costumo dizer que s\u00e3o como \"por favor\" e \"obrigado\", s\u00e3o as fun\u00e7\u00f5es help e dir. A fun\u00e7\u00e3o \"help\" pede ajuda sobre um determinado recurso, funcionando inclusive com palavras reservadas como 'if'. \u00c9 retornado a documenta\u00e7\u00e3o daquele recurso. >>> help ( abs ) Help on built - in function abs in module builtins : abs ( x , / ) Return the absolute value of the argument . >>> help ( 'if' ) The \"if\" statement ****************** The \"if\" statement is used for conditional execution : if_stmt : := \"if\" expression \":\" suite ( \"elif\" expression \":\" suite ) * [ \"else\" \":\" suite ] ... A fun\u00e7\u00e3o \"dir\" lista todos os atributos e m\u00e9todos de uma determinada inst\u00e2ncia. Como em python tudo \u00e9 objeto, esta fun\u00e7\u00e3o mostra como a inst\u00e2ncia do objeto se comporta e quais s\u00e3o seus atributos. >>> dir ( 5 ) [ '__abs__' , '__add__' , '__and__' , '__bool__' , '__ceil__' , '__class__' , '__delattr__' , '__dir__' , '__divmod__' , '__doc__' , '__eq__' , '__float__' , '__floor__' , '__floordiv__' , '__format__' , '__ge__' , '__getattribute__' , '__getnewargs__' , '__gt__' , '__hash__' , '__index__' , '__init__' , '__init_subclass__' , '__int__' , '__invert__' , '__le__' , '__lshift__' , '__lt__' , '__mod__' , '__mul__' , '__ne__' , '__neg__' , '__new__' , '__or__' , '__pos__' , '__pow__' , '__radd__' , '__rand__' , '__rdivmod__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__rfloordiv__' , '__rlshift__' , '__rmod__' , '__rmul__' , '__ror__' , '__round__' , '__rpow__' , '__rrshift__' , '__rshift__' , '__rsub__' , '__rtruediv__' , '__rxor__' , '__setattr__' , '__sizeof__' , '__str__' , '__sub__' , '__subclasshook__' , '__truediv__' , '__trunc__' , '__xor__' , 'bit_length' , 'conjugate' , 'denominator' , 'from_bytes' , 'imag' , 'numerator' , 'real' , 'to_bytes' ]","title":"Por Favor e Obrigado"},{"location":"python/#estrutura-de-chave-e-valor","text":"Python possui por padr\u00e3o uma estrutura de dados de array associativo, que \u00e9 chamado dicion\u00e1rio. Esta estrutura armazena valores associando uma chave a seu conte\u00fado. Veja abaixo algumas tarefas rudimentares com esta estrutura. >>> tarefas = {} # inicializando uma estrutura vazia >>> tarefas [ 1 ] = 'tarefa 1' # definindo uma tarefa de chave 1, com conte\u00fado 'tarefa 1' >>> print ( tarefas [ 1 ]) # exibindo a tarefa 1 >>> tarefas [ 2 ] = 'tarefa 2' # definindo uma tarefa de chave 2, com conte\u00fado 'tarefa 2' >>> tarefas [ 3 ] = 'tarefa-3' # definindo uma tarefa de chave 3, com conte\u00fado 'tarefa 3' >>> tarefas [ 3 ] = 'tarefa 3' # editando uma tarefa >>> del tarefas [ 1 ] # removendo a tarefa","title":"Estrutura de chave e valor"},{"location":"python/#percorrendo-estruturas","text":"O la\u00e7o de repeti\u00e7\u00e3o da linguagem Python \u00e9 atrav\u00e9s de itera\u00e7\u00e3o de cole\u00e7\u00f5es. Tudo que pode ser percorr\u00edvel pode ser utilizado em uma estrutura de repeti\u00e7\u00e3o. >>> for tarefa in tarefas : print ( tarefa )","title":"Percorrendo estruturas"},{"location":"python/#funcoes","text":"Por\u00e7\u00e3o de c\u00f3digo que resolve um problema muito espec\u00edfico. Boas pr\u00e1ticas dizem que uma fun\u00e7\u00e3o deve fazer somente uma coisa e fazer isto bem. def soma ( x , y ): return x + y","title":"Fun\u00e7\u00f5es"},{"location":"python/#decorador","text":"\u00c9 um a\u00e7\u00facar sint\u00e1tico que nos permite alterar mais convenientemente fun\u00e7\u00f5es e m\u00e9todos. Pode ser definido como uma fun\u00e7\u00e3o, que ao inv\u00e9s de retornar algum resultado, retorna a fun\u00e7\u00e3o recebida como par\u00e2metro modificada. def p_decorate ( func ): def func_wrapper ( name ): return \"<p> {} </p>\" . format ( func ( name )) return func_wrapper @p_decorate def get_text ( name ): return \"lorem ipsum, {} dolor sit amet\" . format ( name ) print ( get_text ( \"John\" )) Sa\u00edda: <p>lorem ipsum, John dolor sit amet</p> Vimos um pouco sobre a web, demos uma passada no python, ent\u00e3o agora j\u00e1 vamos come\u00e7ar a escrever c\u00f3digo? Calma, ainda temos mais um conceito que \u00e9 muito importante para n\u00f3s. J\u00e1 ouviu falar do desenvolvimento guiado por testes, que popularmente \u00e9 conhecido pelas letras TDD ? Vamos aprender como e por que escrever testes automatizados antes mesmo de escrever c\u00f3digo.","title":"Decorador"},{"location":"referencias/","text":"\ud83d\udcd1 Refer\u00eancias e Dicas Grupo brasileiro de FastAPI no telegram Integra\u00e7\u00e3o cont\u00ednua e o processo agile URL ou URI, qual a diferen\u00e7a? Guia para entender decoradores (en) Pense em Python Documenta\u00e7\u00e3o do FastAPI Lista de ferramentas adicionais para o FastAPI Test Driven Development by Example - Kent Beck (en) Learning Test-Driven Development - Saleem Siddiqui (en) Canal do Dunossauro Canal sobre Entrega Cont\u00ednua (en)","title":"\ud83d\udcd1 Refer\u00eancias e Dicas"},{"location":"referencias/#referencias-e-dicas","text":"Grupo brasileiro de FastAPI no telegram Integra\u00e7\u00e3o cont\u00ednua e o processo agile URL ou URI, qual a diferen\u00e7a? Guia para entender decoradores (en) Pense em Python Documenta\u00e7\u00e3o do FastAPI Lista de ferramentas adicionais para o FastAPI Test Driven Development by Example - Kent Beck (en) Learning Test-Driven Development - Saleem Siddiqui (en) Canal do Dunossauro Canal sobre Entrega Cont\u00ednua (en)","title":"\ud83d\udcd1 Refer\u00eancias e Dicas"},{"location":"testes/","text":"\ud83d\udc10 Desenvolvimento guiado por testes (TDD) Testes automatizados Talvez tenha chegado aqui sem conhecimento sobre testes automatizados, por isso vamos a uma breve explica\u00e7\u00e3o. \u00c9 muito comum enquanto estamos desenvolvendo, testarmos manualmente as funcionalidades que estamos implementando, mas o que pode ocorrer se eu me esquecer de testar alguma funcionalidade? Por isso escrevemos c\u00f3digo para testar o c\u00f3digo das nossas funcionalidades. Automatizar testes \u00e9 uma maneira de agilizar nosso processo de desenvolvimento, garantindo que novas funcionalidades n\u00e3o impactam sobre as antigas. Um exemplo de teste automatizado. c\u00f3digo def \u00e9_impar ( numero ): 'Retorna True se um n\u00famero \u00e9 verdadeiro, sen\u00e3o False.' return numero % 2 != 0 teste def test_quando_entrada_\u00e9_tr\u00eas_retorna_verdadeiro (): assert \u00e9_impar ( 3 ) is True def test_quando_entrada_\u00e9_dois_retorna_falso (): assert \u00e9_impar ( 2 ) is False \u00c9 importante notar que nos testes eu tento cobrir todas as possibilidades de resultado daquela fun\u00e7\u00e3o, como no exemplo que testo a fun\u00e7\u00e3o para valores pares e \u00edmpares. O que \u00e9 TDD? Desenvolvimento guiado por testes(Test Driven Development) \u00e9 uma t\u00e9cnica de desenvolvimento de software que baseia em um ciclo curto de repeti\u00e7\u00f5es: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Ent\u00e3o, \u00e9 produzido c\u00f3digo que possa ser validado pelo teste para posteriormente o c\u00f3digo ser refatorado para um c\u00f3digo sob padr\u00f5es aceit\u00e1veis. Mas por que TDD? Escrever testes antes do c\u00f3digo ajuda no planejamento da arquitetura da aplica\u00e7\u00e3o, e os testes podem ser um guia de como a aplica\u00e7\u00e3o deve se comportar. O ciclo 1 - Adicione um teste Normalmente analisamos alguma funcionalidade que desejamos implementar ou validar e escrevemos um teste que ser\u00e1 executado automaticamente relacionado aquela funcionalidade. Ainda que uma fun\u00e7\u00e3o/classe n\u00e3o exista, devemos escrever o comportamento esperado da mesma. 2 - Verifique se algum teste quebrou Neste ponto devemos verificar se os testes passam a falhar(os antigos e o que voc\u00ea acabou de escrever) 3 - Escreva c\u00f3digo Escreva c\u00f3digo necess\u00e1rio para que seu teste seja contemplado, mas evite escrever muito al\u00e9m do que necess\u00e1rio. 4 - Refatore seu c\u00f3digo Com os testes passando, analise se \u00e9 poss\u00edvel alguma refatora\u00e7\u00e3o. 5 - Volte para o passo 1 \ud83d\ude1f Ainda n\u00e3o ficou claro o processo? N\u00e3o se preocupe, daqui pra frente iremos ver este ciclo na pr\u00e1tica.","title":"\ud83d\udc10 Desenvolvimento guiado por testes"},{"location":"testes/#desenvolvimento-guiado-por-testes-tdd","text":"","title":"\ud83d\udc10 Desenvolvimento guiado por testes (TDD)"},{"location":"testes/#testes-automatizados","text":"Talvez tenha chegado aqui sem conhecimento sobre testes automatizados, por isso vamos a uma breve explica\u00e7\u00e3o. \u00c9 muito comum enquanto estamos desenvolvendo, testarmos manualmente as funcionalidades que estamos implementando, mas o que pode ocorrer se eu me esquecer de testar alguma funcionalidade? Por isso escrevemos c\u00f3digo para testar o c\u00f3digo das nossas funcionalidades. Automatizar testes \u00e9 uma maneira de agilizar nosso processo de desenvolvimento, garantindo que novas funcionalidades n\u00e3o impactam sobre as antigas. Um exemplo de teste automatizado. c\u00f3digo def \u00e9_impar ( numero ): 'Retorna True se um n\u00famero \u00e9 verdadeiro, sen\u00e3o False.' return numero % 2 != 0 teste def test_quando_entrada_\u00e9_tr\u00eas_retorna_verdadeiro (): assert \u00e9_impar ( 3 ) is True def test_quando_entrada_\u00e9_dois_retorna_falso (): assert \u00e9_impar ( 2 ) is False \u00c9 importante notar que nos testes eu tento cobrir todas as possibilidades de resultado daquela fun\u00e7\u00e3o, como no exemplo que testo a fun\u00e7\u00e3o para valores pares e \u00edmpares.","title":"Testes automatizados"},{"location":"testes/#o-que-e-tdd","text":"Desenvolvimento guiado por testes(Test Driven Development) \u00e9 uma t\u00e9cnica de desenvolvimento de software que baseia em um ciclo curto de repeti\u00e7\u00f5es: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Ent\u00e3o, \u00e9 produzido c\u00f3digo que possa ser validado pelo teste para posteriormente o c\u00f3digo ser refatorado para um c\u00f3digo sob padr\u00f5es aceit\u00e1veis. Mas por que TDD? Escrever testes antes do c\u00f3digo ajuda no planejamento da arquitetura da aplica\u00e7\u00e3o, e os testes podem ser um guia de como a aplica\u00e7\u00e3o deve se comportar.","title":"O que \u00e9 TDD?"},{"location":"testes/#o-ciclo","text":"1 - Adicione um teste Normalmente analisamos alguma funcionalidade que desejamos implementar ou validar e escrevemos um teste que ser\u00e1 executado automaticamente relacionado aquela funcionalidade. Ainda que uma fun\u00e7\u00e3o/classe n\u00e3o exista, devemos escrever o comportamento esperado da mesma. 2 - Verifique se algum teste quebrou Neste ponto devemos verificar se os testes passam a falhar(os antigos e o que voc\u00ea acabou de escrever) 3 - Escreva c\u00f3digo Escreva c\u00f3digo necess\u00e1rio para que seu teste seja contemplado, mas evite escrever muito al\u00e9m do que necess\u00e1rio. 4 - Refatore seu c\u00f3digo Com os testes passando, analise se \u00e9 poss\u00edvel alguma refatora\u00e7\u00e3o. 5 - Volte para o passo 1 \ud83d\ude1f Ainda n\u00e3o ficou claro o processo? N\u00e3o se preocupe, daqui pra frente iremos ver este ciclo na pr\u00e1tica.","title":"O ciclo"},{"location":"web/","text":"\ud83c\udf0e Um pouco sobre a web Antes de avan\u00e7armos com a cria\u00e7\u00e3o da nossa aplica\u00e7\u00e3o, para nivelarmos a turma, vamos dar uma espiada em alguns conceitos de desenvolvimento web. Eles ser\u00e3o necess\u00e1rios para o compreendimento dos t\u00f3picos a seguir. Caso n\u00e3o seja novidade para voc\u00ea, tudo bem, pode pular este passo, mas se n\u00e3o se sentir confiante, d\u00ea uma olhada. Aprenderemos um novo vocabul\u00e1rio com os t\u00f3picos a seguir, que s\u00e3o amplamente utilizados no desenvolvimento web, independente da linguagem. Iremos aprende-los de forma te\u00f3rica e pr\u00e1tica. URIs Conceito Em portugu\u00eas: Identificador de Recursos Universal, como diz o pr\u00f3prio nome, \u00e9 o identificador do recurso. Pode ser uma imagem, uma p\u00e1gina etc., pois tudo o que est\u00e1 dispon\u00edvel na internet precisa de um identificador \u00fanico para que n\u00e3o seja confundido. Pr\u00e1tica Abra um terminal e navegue at\u00e9 dentro do nosso projeto, digite http http://httpbin.org/anything . Nesse caso nosso recurso \u00fanico acessado \u00e9 um texto em formato json, com informa\u00e7\u00f5es sobre a conex\u00e3o. Experimente tamb\u00e9m as seguintes URIs: http https://swapi.dev/api/people/3/ http https://swapi.dev/api/starships/10/ http http://httpbin.org/anything http http://httpbin.org/anything?argumento=valor Na primeira e segunda URI, temos a mudan\u00e7a do nosso recurso, que na primeira URI \u00e9 /api/people/3/ e a segunda \u00e9 /api/starships/10/ . A mudan\u00e7a nesta parte da URI que chamamos de caminho ou path \u00e9 o que caracteriza como outro recurso diferente. A terceira \u00e9 o mesmo caminho da quarta por\u00e9m a presen\u00e7a de parametros na URI pode afetar o retorno daquele recurso. Requisi\u00e7\u00e3o ( request ) e Resposta ( response ) Conceito A comunica\u00e7\u00e3o entre o servidor \u00e9 stateless , o que significa que n\u00e3o h\u00e1 persist\u00eancia de informa\u00e7\u00f5es. Temos ent\u00e3o dois instantes, que s\u00e3o, o momento que o pedido realizado pelo cliente chega ao servidor que referimos como requisi\u00e7\u00e3o ou popularmente conhecido como request e este termo \u00e9 adotado por v\u00e1rios frameworks e outro que \u00e9 a resposta do servidor ao pedido por aquele recurso, que \u00e9 conhecido como resposta ou response . A requisi\u00e7\u00e3o cont\u00e9m informa\u00e7\u00e3o sobre o pedido de um recurso, pode ser um cabe\u00e7alho indicando o tipo daquele recurso ou os tipos de retorno aceitos como resposta. Pode conter dados de um formul\u00e1rio ou argumentos para filtragem de um recurso. A resposta como o pr\u00f3prio nome diz, \u00e9 o recurso pedido pelo cliente. N\u00e3o necessariamente \u00e9 texto, pode ser algum tipo de recurso bin\u00e1rio como imagens. Pr\u00e1tica Experimentem estas uri's. http http://httpbin.org/image/png http http://httpbin.org/encoding/utf8 http http://httpbin.org/xml O primeiro recurso \u00e9 uma imagem em formato png, caso queira ver esta imagem, abra um navegador e cole a url l\u00e1. J\u00e1 o segundo recurso acessado \u00e9 um texto em codifica\u00e7\u00e3o utf-8. E por fim temos um texto em formato xml. Prestem bastante aten\u00e7\u00e3o nos cabe\u00e7alhos. C\u00f3digo de status Conceito A resposta de um servidor pode ser sucesso ou n\u00e3o, pode ser que o recurso pedido tenha sido movido de lugar. Quando h\u00e1 um erro, como saber se o erro foi com o cliente, ou com o servidor? \u00c9 pensando nestas respostas que o protocolo http, utiliza c\u00f3digos que indicam o que ocorreu com a resposta. Os mais famosos deles s\u00e3o o 404 - N\u00e3o encontrado , que me diz que o recurso pedido n\u00e3o foi encontrado. O 200 - OK que significa que a resposta obteve sucesso e tamb\u00e9m 500 - Erro interno do servidor . Alguns outros n\u00e3o t\u00e3o famosos mas tamb\u00e9m importantes s\u00e3o o 201 - Criado , 204 - Nenhum conte\u00fado , 301 - Movido permanentemente , 400 - Requisi\u00e7\u00e3o inv\u00e1lida e o 401 - N\u00e3o autorizado . Uma lista com estes status pode ser encontrada aqui . \u00c9 importante saber que eles s\u00e3o divididos em categorias, aqueles iniciados com 1 s\u00e3o respostas informativas, com 2 s\u00e3o categoria de sucesso, com 3 significa uma redire\u00e7\u00e3o, com 4 erro do cliente e com 5 erro do servidor. Pr\u00e1tica Rode o seguinte comando. http http://httpbin.org/status/418 Experimente trocar o status na uri e veja as mensagens retornadas. Verbos HTTP Conceito Os verbos indicam a a\u00e7\u00e3o executada sobre algum recurso. Os mais famosos s\u00e3o o GET e o POST , que s\u00e3o respons\u00e1veis respectivamente por solicitar uma representa\u00e7\u00e3o de um recurso e submeter uma entidade a um recurso espec\u00edfico, \u00e0s vezes causando uma mudan\u00e7a no estado do recurso. \ud83d\ude15 Uma curiosidade, voc\u00ea sabe a diferen\u00e7a entre o verbo PUT e o PATCH ? O verbo PUT substitui todas as atuais representa\u00e7\u00f5es de seu recurso alvo pela carga de dados da requisi\u00e7\u00e3o, j\u00e1 o PATCH somente modifica parcialmente o recurso. Veja a lista para saber mais sobre os verbos http. Pr\u00e1tica Veja um exemplo de GET . http GET http://httpbin.org/get Um exemplo de post. http POST http://httpbin.org/post data=valor Substitua o verbo e veja funcionando os outros verbos http. Fique atento que os verbos ap\u00f3s o http devem ser escritos com letra mai\u00fascula. \ud83d\ude0a Bem legal n\u00e3o \u00e9? E agora, j\u00e1 vamos logo escrever c\u00f3digo? Sim e n\u00e3o, vamos agora dar uma passada na linguagem Python.","title":"\ud83c\udf0e Um pouco sobre a web"},{"location":"web/#um-pouco-sobre-a-web","text":"Antes de avan\u00e7armos com a cria\u00e7\u00e3o da nossa aplica\u00e7\u00e3o, para nivelarmos a turma, vamos dar uma espiada em alguns conceitos de desenvolvimento web. Eles ser\u00e3o necess\u00e1rios para o compreendimento dos t\u00f3picos a seguir. Caso n\u00e3o seja novidade para voc\u00ea, tudo bem, pode pular este passo, mas se n\u00e3o se sentir confiante, d\u00ea uma olhada. Aprenderemos um novo vocabul\u00e1rio com os t\u00f3picos a seguir, que s\u00e3o amplamente utilizados no desenvolvimento web, independente da linguagem. Iremos aprende-los de forma te\u00f3rica e pr\u00e1tica.","title":"\ud83c\udf0e Um pouco sobre a web"},{"location":"web/#uris","text":"","title":"URIs"},{"location":"web/#conceito","text":"Em portugu\u00eas: Identificador de Recursos Universal, como diz o pr\u00f3prio nome, \u00e9 o identificador do recurso. Pode ser uma imagem, uma p\u00e1gina etc., pois tudo o que est\u00e1 dispon\u00edvel na internet precisa de um identificador \u00fanico para que n\u00e3o seja confundido.","title":"Conceito"},{"location":"web/#pratica","text":"Abra um terminal e navegue at\u00e9 dentro do nosso projeto, digite http http://httpbin.org/anything . Nesse caso nosso recurso \u00fanico acessado \u00e9 um texto em formato json, com informa\u00e7\u00f5es sobre a conex\u00e3o. Experimente tamb\u00e9m as seguintes URIs: http https://swapi.dev/api/people/3/ http https://swapi.dev/api/starships/10/ http http://httpbin.org/anything http http://httpbin.org/anything?argumento=valor Na primeira e segunda URI, temos a mudan\u00e7a do nosso recurso, que na primeira URI \u00e9 /api/people/3/ e a segunda \u00e9 /api/starships/10/ . A mudan\u00e7a nesta parte da URI que chamamos de caminho ou path \u00e9 o que caracteriza como outro recurso diferente. A terceira \u00e9 o mesmo caminho da quarta por\u00e9m a presen\u00e7a de parametros na URI pode afetar o retorno daquele recurso.","title":"Pr\u00e1tica"},{"location":"web/#requisicao-request-e-resposta-response","text":"","title":"Requisi\u00e7\u00e3o (request) e Resposta (response)"},{"location":"web/#conceito_1","text":"A comunica\u00e7\u00e3o entre o servidor \u00e9 stateless , o que significa que n\u00e3o h\u00e1 persist\u00eancia de informa\u00e7\u00f5es. Temos ent\u00e3o dois instantes, que s\u00e3o, o momento que o pedido realizado pelo cliente chega ao servidor que referimos como requisi\u00e7\u00e3o ou popularmente conhecido como request e este termo \u00e9 adotado por v\u00e1rios frameworks e outro que \u00e9 a resposta do servidor ao pedido por aquele recurso, que \u00e9 conhecido como resposta ou response . A requisi\u00e7\u00e3o cont\u00e9m informa\u00e7\u00e3o sobre o pedido de um recurso, pode ser um cabe\u00e7alho indicando o tipo daquele recurso ou os tipos de retorno aceitos como resposta. Pode conter dados de um formul\u00e1rio ou argumentos para filtragem de um recurso. A resposta como o pr\u00f3prio nome diz, \u00e9 o recurso pedido pelo cliente. N\u00e3o necessariamente \u00e9 texto, pode ser algum tipo de recurso bin\u00e1rio como imagens.","title":"Conceito"},{"location":"web/#pratica_1","text":"Experimentem estas uri's. http http://httpbin.org/image/png http http://httpbin.org/encoding/utf8 http http://httpbin.org/xml O primeiro recurso \u00e9 uma imagem em formato png, caso queira ver esta imagem, abra um navegador e cole a url l\u00e1. J\u00e1 o segundo recurso acessado \u00e9 um texto em codifica\u00e7\u00e3o utf-8. E por fim temos um texto em formato xml. Prestem bastante aten\u00e7\u00e3o nos cabe\u00e7alhos.","title":"Pr\u00e1tica"},{"location":"web/#codigo-de-status","text":"","title":"C\u00f3digo de status"},{"location":"web/#conceito_2","text":"A resposta de um servidor pode ser sucesso ou n\u00e3o, pode ser que o recurso pedido tenha sido movido de lugar. Quando h\u00e1 um erro, como saber se o erro foi com o cliente, ou com o servidor? \u00c9 pensando nestas respostas que o protocolo http, utiliza c\u00f3digos que indicam o que ocorreu com a resposta. Os mais famosos deles s\u00e3o o 404 - N\u00e3o encontrado , que me diz que o recurso pedido n\u00e3o foi encontrado. O 200 - OK que significa que a resposta obteve sucesso e tamb\u00e9m 500 - Erro interno do servidor . Alguns outros n\u00e3o t\u00e3o famosos mas tamb\u00e9m importantes s\u00e3o o 201 - Criado , 204 - Nenhum conte\u00fado , 301 - Movido permanentemente , 400 - Requisi\u00e7\u00e3o inv\u00e1lida e o 401 - N\u00e3o autorizado . Uma lista com estes status pode ser encontrada aqui . \u00c9 importante saber que eles s\u00e3o divididos em categorias, aqueles iniciados com 1 s\u00e3o respostas informativas, com 2 s\u00e3o categoria de sucesso, com 3 significa uma redire\u00e7\u00e3o, com 4 erro do cliente e com 5 erro do servidor.","title":"Conceito"},{"location":"web/#pratica_2","text":"Rode o seguinte comando. http http://httpbin.org/status/418 Experimente trocar o status na uri e veja as mensagens retornadas.","title":"Pr\u00e1tica"},{"location":"web/#verbos-http","text":"","title":"Verbos HTTP"},{"location":"web/#conceito_3","text":"Os verbos indicam a a\u00e7\u00e3o executada sobre algum recurso. Os mais famosos s\u00e3o o GET e o POST , que s\u00e3o respons\u00e1veis respectivamente por solicitar uma representa\u00e7\u00e3o de um recurso e submeter uma entidade a um recurso espec\u00edfico, \u00e0s vezes causando uma mudan\u00e7a no estado do recurso. \ud83d\ude15 Uma curiosidade, voc\u00ea sabe a diferen\u00e7a entre o verbo PUT e o PATCH ? O verbo PUT substitui todas as atuais representa\u00e7\u00f5es de seu recurso alvo pela carga de dados da requisi\u00e7\u00e3o, j\u00e1 o PATCH somente modifica parcialmente o recurso. Veja a lista para saber mais sobre os verbos http.","title":"Conceito"},{"location":"web/#pratica_3","text":"Veja um exemplo de GET . http GET http://httpbin.org/get Um exemplo de post. http POST http://httpbin.org/post data=valor Substitua o verbo e veja funcionando os outros verbos http. Fique atento que os verbos ap\u00f3s o http devem ser escritos com letra mai\u00fascula. \ud83d\ude0a Bem legal n\u00e3o \u00e9? E agora, j\u00e1 vamos logo escrever c\u00f3digo? Sim e n\u00e3o, vamos agora dar uma passada na linguagem Python.","title":"Pr\u00e1tica"}]}